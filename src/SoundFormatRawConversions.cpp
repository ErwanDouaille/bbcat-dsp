// This code is auto-generated by genconversions.php -> DO NOT EDIT!!
//
// Don't call these functions directly!  Use TransferSamples(), see SoundFormatConversions.h

#include <string.h>
#include <math.h>

#define BBCDEBUG_LEVEL 1
#include "SoundFormatRawConversions.h"

BBC_AUDIOTOOLBOX_START

// macro to reduce the ugliness of using static_cast
#define cast(type,val) static_cast<type>(val)

// macro to directly access memory via the specified type
#define mem(type,var)       (*(type *)(var))
#define const_mem(type,var) (*(const type *)(var))

static void __CopyMemory_2(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  uint_t i;

  (void)ditherer;
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    if (dst != src) memcpy(dst, src, nchannels * 2);
  }
}

static void __CopyMemory_3(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  uint_t i;

  (void)ditherer;
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    if (dst != src) memcpy(dst, src, nchannels * 3);
  }
}

static void __CopyMemory_4(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  uint_t i;

  (void)ditherer;
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    if (dst != src) memcpy(dst, src, nchannels * 4);
  }
}

static void __CopyMemory_8(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  uint_t i;

  (void)ditherer;
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    if (dst != src) memcpy(dst, src, nchannels * 8);
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 16bit (LE) samples to 24bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_16bitLE_to_24bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  sint32_t sval;
  sint32_t dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // destination samples are bigger -> start from end of frame and work backwards
  src += nchannels * 2 - 2;
  dst += nchannels * 3 - 3;

  // adjust frame increments for effects of for-loop
  srcflen += nchannels * 2;
  dstflen += nchannels * 3;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src -= 2, dst -= 3)
    {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // read 16-bit sample and convert to 32-bit sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = cast(uint32_t, const_mem(sint16_t, src) << 16);
#else
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[1]) << 24) + (cast(uint32_t, src[0]) << 16);
#endif
      // write sample bytes to destination
      dst[2] = cast(uint8_t, sval >> 24);
      dst[1] = cast(uint8_t, sval >> 16);
      dst[0] = cast(uint8_t, sval >> 8);
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 16bit (LE) samples to 32bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_16bitLE_to_32bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  sint32_t sval;
  sint32_t dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // destination samples are bigger -> start from end of frame and work backwards
  src += nchannels * 2 - 2;
  dst += nchannels * 4 - 4;

  // adjust frame increments for effects of for-loop
  srcflen += nchannels * 2;
  dstflen += nchannels * 4;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src -= 2, dst -= 4)
    {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // read 16-bit sample and convert to 32-bit sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = cast(uint32_t, const_mem(sint16_t, src) << 16);
#else
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[1]) << 24) + (cast(uint32_t, src[0]) << 16);
#endif
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // write integer sample directly
      mem(sint32_t, dst) = sval;
#else
      // write sample bytes to destination
      dst[3] = cast(uint8_t, sval >> 24);
      dst[2] = cast(uint8_t, sval >> 16);
      dst[1] = cast(uint8_t, sval >> 8);
      dst[0] = cast(uint8_t, sval);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 16bit (LE) samples to Float (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_16bitLE_to_FloatLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const float factor = cast(float, pow(2.0, -31.0));
  sint32_t sval;
  float    dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // destination samples are bigger -> start from end of frame and work backwards
  src += nchannels * 2 - 2;
  dst += nchannels * 4 - 4;

  // adjust frame increments for effects of for-loop
  srcflen += nchannels * 2;
  dstflen += nchannels * 4;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src -= 2, dst -= 4)
    {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // read 16-bit sample and convert to 32-bit sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = cast(uint32_t, const_mem(sint16_t, src) << 16);
#else
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[1]) << 24) + (cast(uint32_t, src[0]) << 16);
#endif
      // convert integer sample to floating point sample (scale)
      dval = cast(float, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // write floating point sample directly
      mem(float, dst) = dval;
#else
      // write sample bytes to destination
      dst[3] = cast(uint8_t, dvp[0] >> 24);
      dst[2] = cast(uint8_t, dvp[0] >> 16);
      dst[1] = cast(uint8_t, dvp[0] >> 8);
      dst[0] = cast(uint8_t, dvp[0]);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 16bit (LE) samples to Double (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_16bitLE_to_DoubleLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const double factor = cast(double, pow(2.0, -31.0));
  sint32_t sval;
  double   dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint64_t *dvp = (uint64_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // destination samples are bigger -> start from end of frame and work backwards
  src += nchannels * 2 - 2;
  dst += nchannels * 8 - 8;

  // adjust frame increments for effects of for-loop
  srcflen += nchannels * 2;
  dstflen += nchannels * 8;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src -= 2, dst -= 8)
    {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // read 16-bit sample and convert to 32-bit sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = cast(uint32_t, const_mem(sint16_t, src) << 16);
#else
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[1]) << 24) + (cast(uint32_t, src[0]) << 16);
#endif
      // convert integer sample to floating point sample (scale)
      dval = cast(double, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // write floating point sample directly
      mem(double, dst) = dval;
#else
      // write sample bytes to destination
      dst[7] = cast(uint8_t, dvp[0] >> 56);
      dst[6] = cast(uint8_t, dvp[0] >> 48);
      dst[5] = cast(uint8_t, dvp[0] >> 40);
      dst[4] = cast(uint8_t, dvp[0] >> 32);
      dst[3] = cast(uint8_t, dvp[0] >> 24);
      dst[2] = cast(uint8_t, dvp[0] >> 16);
      dst[1] = cast(uint8_t, dvp[0] >> 8);
      dst[0] = cast(uint8_t, dvp[0]);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 24bit (LE) samples to 16bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_24bitLE_to_16bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  sint32_t sval;
  sint32_t dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 3;
  dstflen -= nchannels * 2;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 3, dst += 2)
    {
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[2]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[0]) << 8);
      // apply dither
      if (ditherer) ditherer->Dither(i, sval, 16);
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // write 16-bit integer sample directly
      mem(sint16_t, dst) = cast(sint16_t, sval >> 16);
#else
      // write sample bytes to destination
      dst[1] = cast(uint8_t, sval >> 24);
      dst[0] = cast(uint8_t, sval >> 16);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 24bit (LE) samples to 32bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_24bitLE_to_32bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  sint32_t sval;
  sint32_t dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // destination samples are bigger -> start from end of frame and work backwards
  src += nchannels * 3 - 3;
  dst += nchannels * 4 - 4;

  // adjust frame increments for effects of for-loop
  srcflen += nchannels * 3;
  dstflen += nchannels * 4;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src -= 3, dst -= 4)
    {
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[2]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[0]) << 8);
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // write integer sample directly
      mem(sint32_t, dst) = sval;
#else
      // write sample bytes to destination
      dst[3] = cast(uint8_t, sval >> 24);
      dst[2] = cast(uint8_t, sval >> 16);
      dst[1] = cast(uint8_t, sval >> 8);
      dst[0] = cast(uint8_t, sval);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 24bit (LE) samples to Float (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_24bitLE_to_FloatLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const float factor = cast(float, pow(2.0, -31.0));
  sint32_t sval;
  float    dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // destination samples are bigger -> start from end of frame and work backwards
  src += nchannels * 3 - 3;
  dst += nchannels * 4 - 4;

  // adjust frame increments for effects of for-loop
  srcflen += nchannels * 3;
  dstflen += nchannels * 4;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src -= 3, dst -= 4)
    {
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[2]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[0]) << 8);
      // convert integer sample to floating point sample (scale)
      dval = cast(float, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // write floating point sample directly
      mem(float, dst) = dval;
#else
      // write sample bytes to destination
      dst[3] = cast(uint8_t, dvp[0] >> 24);
      dst[2] = cast(uint8_t, dvp[0] >> 16);
      dst[1] = cast(uint8_t, dvp[0] >> 8);
      dst[0] = cast(uint8_t, dvp[0]);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 24bit (LE) samples to Double (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_24bitLE_to_DoubleLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const double factor = cast(double, pow(2.0, -31.0));
  sint32_t sval;
  double   dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint64_t *dvp = (uint64_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // destination samples are bigger -> start from end of frame and work backwards
  src += nchannels * 3 - 3;
  dst += nchannels * 8 - 8;

  // adjust frame increments for effects of for-loop
  srcflen += nchannels * 3;
  dstflen += nchannels * 8;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src -= 3, dst -= 8)
    {
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[2]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[0]) << 8);
      // convert integer sample to floating point sample (scale)
      dval = cast(double, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // write floating point sample directly
      mem(double, dst) = dval;
#else
      // write sample bytes to destination
      dst[7] = cast(uint8_t, dvp[0] >> 56);
      dst[6] = cast(uint8_t, dvp[0] >> 48);
      dst[5] = cast(uint8_t, dvp[0] >> 40);
      dst[4] = cast(uint8_t, dvp[0] >> 32);
      dst[3] = cast(uint8_t, dvp[0] >> 24);
      dst[2] = cast(uint8_t, dvp[0] >> 16);
      dst[1] = cast(uint8_t, dvp[0] >> 8);
      dst[0] = cast(uint8_t, dvp[0]);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 32bit (LE) samples to 16bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_32bitLE_to_16bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  sint32_t sval;
  sint32_t dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 4;
  dstflen -= nchannels * 2;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 4, dst += 2)
    {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // read integer sample directly
      sval = const_mem(sint32_t, src);
#else
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[3]) << 24) + (cast(uint32_t, src[2]) << 16) + (cast(uint32_t, src[1]) << 8) + (cast(uint32_t, src[0]));
#endif
      // apply dither
      if (ditherer) ditherer->Dither(i, sval, 16);
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // write 16-bit integer sample directly
      mem(sint16_t, dst) = cast(sint16_t, sval >> 16);
#else
      // write sample bytes to destination
      dst[1] = cast(uint8_t, sval >> 24);
      dst[0] = cast(uint8_t, sval >> 16);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 32bit (LE) samples to 24bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_32bitLE_to_24bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  sint32_t sval;
  sint32_t dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 4;
  dstflen -= nchannels * 3;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 4, dst += 3)
    {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // read integer sample directly
      sval = const_mem(sint32_t, src);
#else
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[3]) << 24) + (cast(uint32_t, src[2]) << 16) + (cast(uint32_t, src[1]) << 8) + (cast(uint32_t, src[0]));
#endif
      // apply dither
      if (ditherer) ditherer->Dither(i, sval, 8);
      // write sample bytes to destination
      dst[2] = cast(uint8_t, sval >> 24);
      dst[1] = cast(uint8_t, sval >> 16);
      dst[0] = cast(uint8_t, sval >> 8);
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 32bit (LE) samples to Float (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_32bitLE_to_FloatLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const float factor = cast(float, pow(2.0, -31.0));
  sint32_t sval;
  float    dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // destination samples are bigger -> start from end of frame and work backwards
  src += nchannels * 4 - 4;
  dst += nchannels * 4 - 4;

  // adjust frame increments for effects of for-loop
  srcflen += nchannels * 4;
  dstflen += nchannels * 4;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src -= 4, dst -= 4)
    {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // read integer sample directly
      sval = const_mem(sint32_t, src);
#else
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[3]) << 24) + (cast(uint32_t, src[2]) << 16) + (cast(uint32_t, src[1]) << 8) + (cast(uint32_t, src[0]));
#endif
      // convert integer sample to floating point sample (scale)
      dval = cast(float, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // write floating point sample directly
      mem(float, dst) = dval;
#else
      // write sample bytes to destination
      dst[3] = cast(uint8_t, dvp[0] >> 24);
      dst[2] = cast(uint8_t, dvp[0] >> 16);
      dst[1] = cast(uint8_t, dvp[0] >> 8);
      dst[0] = cast(uint8_t, dvp[0]);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 32bit (LE) samples to Double (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_32bitLE_to_DoubleLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const double factor = cast(double, pow(2.0, -31.0));
  sint32_t sval;
  double   dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint64_t *dvp = (uint64_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // destination samples are bigger -> start from end of frame and work backwards
  src += nchannels * 4 - 4;
  dst += nchannels * 8 - 8;

  // adjust frame increments for effects of for-loop
  srcflen += nchannels * 4;
  dstflen += nchannels * 8;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src -= 4, dst -= 8)
    {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // read integer sample directly
      sval = const_mem(sint32_t, src);
#else
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[3]) << 24) + (cast(uint32_t, src[2]) << 16) + (cast(uint32_t, src[1]) << 8) + (cast(uint32_t, src[0]));
#endif
      // convert integer sample to floating point sample (scale)
      dval = cast(double, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // write floating point sample directly
      mem(double, dst) = dval;
#else
      // write sample bytes to destination
      dst[7] = cast(uint8_t, dvp[0] >> 56);
      dst[6] = cast(uint8_t, dvp[0] >> 48);
      dst[5] = cast(uint8_t, dvp[0] >> 40);
      dst[4] = cast(uint8_t, dvp[0] >> 32);
      dst[3] = cast(uint8_t, dvp[0] >> 24);
      dst[2] = cast(uint8_t, dvp[0] >> 16);
      dst[1] = cast(uint8_t, dvp[0] >> 8);
      dst[0] = cast(uint8_t, dvp[0]);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert Float (LE) samples to 16bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_FloatLE_to_16bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const double factor = pow(2.0, 31.0);
  float    sval;
  sint32_t dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 4;
  dstflen -= nchannels * 2;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 4, dst += 2)
    {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // read floating point sample directly
      sval = const_mem(float, src);
#else
      // read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
      svp[0] = (cast(uint32_t, src[3]) << 24) + (cast(uint32_t, src[2]) << 16) + (cast(uint32_t, src[1]) << 8) + (cast(uint32_t, src[0]));
#endif
      // apply dither
      if (ditherer) ditherer->Dither(i, sval, 16);
      // convert floating point sample to integer sample (scale and limit)
      dval = cast(sint32_t, limited::limit(sval * factor, -2147483648.0, 2147483647.0));
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // write 16-bit integer sample directly
      mem(sint16_t, dst) = cast(sint16_t, dval >> 16);
#else
      // write sample bytes to destination
      dst[1] = cast(uint8_t, dvp[0] >> 24);
      dst[0] = cast(uint8_t, dvp[0] >> 16);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert Float (LE) samples to 24bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_FloatLE_to_24bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const double factor = pow(2.0, 31.0);
  float    sval;
  sint32_t dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 4;
  dstflen -= nchannels * 3;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 4, dst += 3)
    {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // read floating point sample directly
      sval = const_mem(float, src);
#else
      // read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
      svp[0] = (cast(uint32_t, src[3]) << 24) + (cast(uint32_t, src[2]) << 16) + (cast(uint32_t, src[1]) << 8) + (cast(uint32_t, src[0]));
#endif
      // apply dither
      if (ditherer) ditherer->Dither(i, sval, 8);
      // convert floating point sample to integer sample (scale and limit)
      dval = cast(sint32_t, limited::limit(sval * factor, -2147483648.0, 2147483647.0));
      // write sample bytes to destination
      dst[2] = cast(uint8_t, dvp[0] >> 24);
      dst[1] = cast(uint8_t, dvp[0] >> 16);
      dst[0] = cast(uint8_t, dvp[0] >> 8);
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert Float (LE) samples to 32bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_FloatLE_to_32bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const double factor = pow(2.0, 31.0);
  float    sval;
  sint32_t dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 4;
  dstflen -= nchannels * 4;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 4, dst += 4)
    {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // read floating point sample directly
      sval = const_mem(float, src);
#else
      // read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
      svp[0] = (cast(uint32_t, src[3]) << 24) + (cast(uint32_t, src[2]) << 16) + (cast(uint32_t, src[1]) << 8) + (cast(uint32_t, src[0]));
#endif
      // convert floating point sample to integer sample (scale and limit)
      dval = cast(sint32_t, limited::limit(sval * factor, -2147483648.0, 2147483647.0));
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // write integer sample directly
      mem(sint32_t, dst) = dval;
#else
      // write sample bytes to destination
      dst[3] = cast(uint8_t, dvp[0] >> 24);
      dst[2] = cast(uint8_t, dvp[0] >> 16);
      dst[1] = cast(uint8_t, dvp[0] >> 8);
      dst[0] = cast(uint8_t, dvp[0]);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert Float (LE) samples to Double (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_FloatLE_to_DoubleLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  float    sval;
  double   dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint64_t *dvp = (uint64_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // destination samples are bigger -> start from end of frame and work backwards
  src += nchannels * 4 - 4;
  dst += nchannels * 8 - 8;

  // adjust frame increments for effects of for-loop
  srcflen += nchannels * 4;
  dstflen += nchannels * 8;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src -= 4, dst -= 8)
    {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // read floating point sample directly
      sval = const_mem(float, src);
#else
      // read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
      svp[0] = (cast(uint32_t, src[3]) << 24) + (cast(uint32_t, src[2]) << 16) + (cast(uint32_t, src[1]) << 8) + (cast(uint32_t, src[0]));
#endif
      // convert one type of floating point sample to another
      dval = cast(double, sval);
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // write floating point sample directly
      mem(double, dst) = dval;
#else
      // write sample bytes to destination
      dst[7] = cast(uint8_t, dvp[0] >> 56);
      dst[6] = cast(uint8_t, dvp[0] >> 48);
      dst[5] = cast(uint8_t, dvp[0] >> 40);
      dst[4] = cast(uint8_t, dvp[0] >> 32);
      dst[3] = cast(uint8_t, dvp[0] >> 24);
      dst[2] = cast(uint8_t, dvp[0] >> 16);
      dst[1] = cast(uint8_t, dvp[0] >> 8);
      dst[0] = cast(uint8_t, dvp[0]);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert Double (LE) samples to 16bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_DoubleLE_to_16bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const double factor = pow(2.0, 31.0);
  double   sval;
  sint32_t dval;
  uint64_t *svp = (uint64_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 8;
  dstflen -= nchannels * 2;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 8, dst += 2)
    {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // read floating point sample directly
      sval = const_mem(double, src);
#else
      // read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
      svp[0] = (cast(uint64_t, src[7]) << 56) + (cast(uint64_t, src[6]) << 48) + (cast(uint64_t, src[5]) << 40) + (cast(uint64_t, src[4]) << 32) + (cast(uint64_t, src[3]) << 24) + (cast(uint64_t, src[2]) << 16) + (cast(uint64_t, src[1]) << 8) + (cast(uint64_t, src[0]));
#endif
      // apply dither
      if (ditherer) ditherer->Dither(i, sval, 16);
      // convert floating point sample to integer sample (scale and limit)
      dval = cast(sint32_t, limited::limit(sval * factor, -2147483648.0, 2147483647.0));
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // write 16-bit integer sample directly
      mem(sint16_t, dst) = cast(sint16_t, dval >> 16);
#else
      // write sample bytes to destination
      dst[1] = cast(uint8_t, dvp[0] >> 24);
      dst[0] = cast(uint8_t, dvp[0] >> 16);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert Double (LE) samples to 24bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_DoubleLE_to_24bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const double factor = pow(2.0, 31.0);
  double   sval;
  sint32_t dval;
  uint64_t *svp = (uint64_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 8;
  dstflen -= nchannels * 3;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 8, dst += 3)
    {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // read floating point sample directly
      sval = const_mem(double, src);
#else
      // read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
      svp[0] = (cast(uint64_t, src[7]) << 56) + (cast(uint64_t, src[6]) << 48) + (cast(uint64_t, src[5]) << 40) + (cast(uint64_t, src[4]) << 32) + (cast(uint64_t, src[3]) << 24) + (cast(uint64_t, src[2]) << 16) + (cast(uint64_t, src[1]) << 8) + (cast(uint64_t, src[0]));
#endif
      // apply dither
      if (ditherer) ditherer->Dither(i, sval, 8);
      // convert floating point sample to integer sample (scale and limit)
      dval = cast(sint32_t, limited::limit(sval * factor, -2147483648.0, 2147483647.0));
      // write sample bytes to destination
      dst[2] = cast(uint8_t, dvp[0] >> 24);
      dst[1] = cast(uint8_t, dvp[0] >> 16);
      dst[0] = cast(uint8_t, dvp[0] >> 8);
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert Double (LE) samples to 32bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_DoubleLE_to_32bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const double factor = pow(2.0, 31.0);
  double   sval;
  sint32_t dval;
  uint64_t *svp = (uint64_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 8;
  dstflen -= nchannels * 4;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 8, dst += 4)
    {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // read floating point sample directly
      sval = const_mem(double, src);
#else
      // read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
      svp[0] = (cast(uint64_t, src[7]) << 56) + (cast(uint64_t, src[6]) << 48) + (cast(uint64_t, src[5]) << 40) + (cast(uint64_t, src[4]) << 32) + (cast(uint64_t, src[3]) << 24) + (cast(uint64_t, src[2]) << 16) + (cast(uint64_t, src[1]) << 8) + (cast(uint64_t, src[0]));
#endif
      // apply dither
      if (ditherer) ditherer->Dither(i, sval, 0);
      // convert floating point sample to integer sample (scale and limit)
      dval = cast(sint32_t, limited::limit(sval * factor, -2147483648.0, 2147483647.0));
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // write integer sample directly
      mem(sint32_t, dst) = dval;
#else
      // write sample bytes to destination
      dst[3] = cast(uint8_t, dvp[0] >> 24);
      dst[2] = cast(uint8_t, dvp[0] >> 16);
      dst[1] = cast(uint8_t, dvp[0] >> 8);
      dst[0] = cast(uint8_t, dvp[0]);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert Double (LE) samples to Float (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_DoubleLE_to_FloatLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  double   sval;
  float    dval;
  uint64_t *svp = (uint64_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 8;
  dstflen -= nchannels * 4;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 8, dst += 4)
    {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // read floating point sample directly
      sval = const_mem(double, src);
#else
      // read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
      svp[0] = (cast(uint64_t, src[7]) << 56) + (cast(uint64_t, src[6]) << 48) + (cast(uint64_t, src[5]) << 40) + (cast(uint64_t, src[4]) << 32) + (cast(uint64_t, src[3]) << 24) + (cast(uint64_t, src[2]) << 16) + (cast(uint64_t, src[1]) << 8) + (cast(uint64_t, src[0]));
#endif
      // convert one type of floating point sample to another
      dval = cast(float, sval);
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // write floating point sample directly
      mem(float, dst) = dval;
#else
      // write sample bytes to destination
      dst[3] = cast(uint8_t, dvp[0] >> 24);
      dst[2] = cast(uint8_t, dvp[0] >> 16);
      dst[1] = cast(uint8_t, dvp[0] >> 8);
      dst[0] = cast(uint8_t, dvp[0]);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 16bit (LE) samples to 16bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_16bitLE_to_16bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  sint32_t sval;
  sint32_t dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 2;
  dstflen -= nchannels * 2;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 2, dst += 2)
    {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // read 16-bit sample and convert to 32-bit sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = cast(uint32_t, const_mem(sint16_t, src) << 16);
#else
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[1]) << 24) + (cast(uint32_t, src[0]) << 16);
#endif
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // write 16-bit integer sample directly
      mem(sint16_t, dst) = cast(sint16_t, sval >> 16);
#else
      // write sample bytes to destination
      dst[0] = cast(uint8_t, sval >> 24);
      dst[1] = cast(uint8_t, sval >> 16);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 16bit (LE) samples to 24bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_16bitLE_to_24bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  sint32_t sval;
  sint32_t dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // destination samples are bigger -> start from end of frame and work backwards
  src += nchannels * 2 - 2;
  dst += nchannels * 3 - 3;

  // adjust frame increments for effects of for-loop
  srcflen += nchannels * 2;
  dstflen += nchannels * 3;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src -= 2, dst -= 3)
    {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // read 16-bit sample and convert to 32-bit sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = cast(uint32_t, const_mem(sint16_t, src) << 16);
#else
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[1]) << 24) + (cast(uint32_t, src[0]) << 16);
#endif
      // write sample bytes to destination
      dst[0] = cast(uint8_t, sval >> 24);
      dst[1] = cast(uint8_t, sval >> 16);
      dst[2] = cast(uint8_t, sval >> 8);
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 16bit (LE) samples to 32bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_16bitLE_to_32bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  sint32_t sval;
  sint32_t dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // destination samples are bigger -> start from end of frame and work backwards
  src += nchannels * 2 - 2;
  dst += nchannels * 4 - 4;

  // adjust frame increments for effects of for-loop
  srcflen += nchannels * 2;
  dstflen += nchannels * 4;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src -= 2, dst -= 4)
    {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // read 16-bit sample and convert to 32-bit sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = cast(uint32_t, const_mem(sint16_t, src) << 16);
#else
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[1]) << 24) + (cast(uint32_t, src[0]) << 16);
#endif
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // write integer sample directly
      mem(sint32_t, dst) = sval;
#else
      // write sample bytes to destination
      dst[0] = cast(uint8_t, sval >> 24);
      dst[1] = cast(uint8_t, sval >> 16);
      dst[2] = cast(uint8_t, sval >> 8);
      dst[3] = cast(uint8_t, sval);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 16bit (LE) samples to Float (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_16bitLE_to_FloatBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const float factor = cast(float, pow(2.0, -31.0));
  sint32_t sval;
  float    dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // destination samples are bigger -> start from end of frame and work backwards
  src += nchannels * 2 - 2;
  dst += nchannels * 4 - 4;

  // adjust frame increments for effects of for-loop
  srcflen += nchannels * 2;
  dstflen += nchannels * 4;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src -= 2, dst -= 4)
    {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // read 16-bit sample and convert to 32-bit sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = cast(uint32_t, const_mem(sint16_t, src) << 16);
#else
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[1]) << 24) + (cast(uint32_t, src[0]) << 16);
#endif
      // convert integer sample to floating point sample (scale)
      dval = cast(float, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // write floating point sample directly
      mem(float, dst) = dval;
#else
      // write sample bytes to destination
      dst[0] = cast(uint8_t, dvp[0] >> 24);
      dst[1] = cast(uint8_t, dvp[0] >> 16);
      dst[2] = cast(uint8_t, dvp[0] >> 8);
      dst[3] = cast(uint8_t, dvp[0]);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 16bit (LE) samples to Double (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_16bitLE_to_DoubleBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const double factor = cast(double, pow(2.0, -31.0));
  sint32_t sval;
  double   dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint64_t *dvp = (uint64_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // destination samples are bigger -> start from end of frame and work backwards
  src += nchannels * 2 - 2;
  dst += nchannels * 8 - 8;

  // adjust frame increments for effects of for-loop
  srcflen += nchannels * 2;
  dstflen += nchannels * 8;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src -= 2, dst -= 8)
    {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // read 16-bit sample and convert to 32-bit sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = cast(uint32_t, const_mem(sint16_t, src) << 16);
#else
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[1]) << 24) + (cast(uint32_t, src[0]) << 16);
#endif
      // convert integer sample to floating point sample (scale)
      dval = cast(double, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // write floating point sample directly
      mem(double, dst) = dval;
#else
      // write sample bytes to destination
      dst[0] = cast(uint8_t, dvp[0] >> 56);
      dst[1] = cast(uint8_t, dvp[0] >> 48);
      dst[2] = cast(uint8_t, dvp[0] >> 40);
      dst[3] = cast(uint8_t, dvp[0] >> 32);
      dst[4] = cast(uint8_t, dvp[0] >> 24);
      dst[5] = cast(uint8_t, dvp[0] >> 16);
      dst[6] = cast(uint8_t, dvp[0] >> 8);
      dst[7] = cast(uint8_t, dvp[0]);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 24bit (LE) samples to 16bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_24bitLE_to_16bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  sint32_t sval;
  sint32_t dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 3;
  dstflen -= nchannels * 2;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 3, dst += 2)
    {
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[2]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[0]) << 8);
      // apply dither
      if (ditherer) ditherer->Dither(i, sval, 16);
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // write 16-bit integer sample directly
      mem(sint16_t, dst) = cast(sint16_t, sval >> 16);
#else
      // write sample bytes to destination
      dst[0] = cast(uint8_t, sval >> 24);
      dst[1] = cast(uint8_t, sval >> 16);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 24bit (LE) samples to 24bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_24bitLE_to_24bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  sint32_t sval;
  sint32_t dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 3;
  dstflen -= nchannels * 3;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 3, dst += 3)
    {
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[2]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[0]) << 8);
      // write sample bytes to destination
      dst[0] = cast(uint8_t, sval >> 24);
      dst[1] = cast(uint8_t, sval >> 16);
      dst[2] = cast(uint8_t, sval >> 8);
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 24bit (LE) samples to 32bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_24bitLE_to_32bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  sint32_t sval;
  sint32_t dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // destination samples are bigger -> start from end of frame and work backwards
  src += nchannels * 3 - 3;
  dst += nchannels * 4 - 4;

  // adjust frame increments for effects of for-loop
  srcflen += nchannels * 3;
  dstflen += nchannels * 4;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src -= 3, dst -= 4)
    {
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[2]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[0]) << 8);
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // write integer sample directly
      mem(sint32_t, dst) = sval;
#else
      // write sample bytes to destination
      dst[0] = cast(uint8_t, sval >> 24);
      dst[1] = cast(uint8_t, sval >> 16);
      dst[2] = cast(uint8_t, sval >> 8);
      dst[3] = cast(uint8_t, sval);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 24bit (LE) samples to Float (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_24bitLE_to_FloatBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const float factor = cast(float, pow(2.0, -31.0));
  sint32_t sval;
  float    dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // destination samples are bigger -> start from end of frame and work backwards
  src += nchannels * 3 - 3;
  dst += nchannels * 4 - 4;

  // adjust frame increments for effects of for-loop
  srcflen += nchannels * 3;
  dstflen += nchannels * 4;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src -= 3, dst -= 4)
    {
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[2]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[0]) << 8);
      // convert integer sample to floating point sample (scale)
      dval = cast(float, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // write floating point sample directly
      mem(float, dst) = dval;
#else
      // write sample bytes to destination
      dst[0] = cast(uint8_t, dvp[0] >> 24);
      dst[1] = cast(uint8_t, dvp[0] >> 16);
      dst[2] = cast(uint8_t, dvp[0] >> 8);
      dst[3] = cast(uint8_t, dvp[0]);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 24bit (LE) samples to Double (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_24bitLE_to_DoubleBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const double factor = cast(double, pow(2.0, -31.0));
  sint32_t sval;
  double   dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint64_t *dvp = (uint64_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // destination samples are bigger -> start from end of frame and work backwards
  src += nchannels * 3 - 3;
  dst += nchannels * 8 - 8;

  // adjust frame increments for effects of for-loop
  srcflen += nchannels * 3;
  dstflen += nchannels * 8;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src -= 3, dst -= 8)
    {
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[2]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[0]) << 8);
      // convert integer sample to floating point sample (scale)
      dval = cast(double, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // write floating point sample directly
      mem(double, dst) = dval;
#else
      // write sample bytes to destination
      dst[0] = cast(uint8_t, dvp[0] >> 56);
      dst[1] = cast(uint8_t, dvp[0] >> 48);
      dst[2] = cast(uint8_t, dvp[0] >> 40);
      dst[3] = cast(uint8_t, dvp[0] >> 32);
      dst[4] = cast(uint8_t, dvp[0] >> 24);
      dst[5] = cast(uint8_t, dvp[0] >> 16);
      dst[6] = cast(uint8_t, dvp[0] >> 8);
      dst[7] = cast(uint8_t, dvp[0]);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 32bit (LE) samples to 16bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_32bitLE_to_16bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  sint32_t sval;
  sint32_t dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 4;
  dstflen -= nchannels * 2;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 4, dst += 2)
    {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // read integer sample directly
      sval = const_mem(sint32_t, src);
#else
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[3]) << 24) + (cast(uint32_t, src[2]) << 16) + (cast(uint32_t, src[1]) << 8) + (cast(uint32_t, src[0]));
#endif
      // apply dither
      if (ditherer) ditherer->Dither(i, sval, 16);
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // write 16-bit integer sample directly
      mem(sint16_t, dst) = cast(sint16_t, sval >> 16);
#else
      // write sample bytes to destination
      dst[0] = cast(uint8_t, sval >> 24);
      dst[1] = cast(uint8_t, sval >> 16);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 32bit (LE) samples to 24bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_32bitLE_to_24bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  sint32_t sval;
  sint32_t dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 4;
  dstflen -= nchannels * 3;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 4, dst += 3)
    {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // read integer sample directly
      sval = const_mem(sint32_t, src);
#else
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[3]) << 24) + (cast(uint32_t, src[2]) << 16) + (cast(uint32_t, src[1]) << 8) + (cast(uint32_t, src[0]));
#endif
      // apply dither
      if (ditherer) ditherer->Dither(i, sval, 8);
      // write sample bytes to destination
      dst[0] = cast(uint8_t, sval >> 24);
      dst[1] = cast(uint8_t, sval >> 16);
      dst[2] = cast(uint8_t, sval >> 8);
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 32bit (LE) samples to 32bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_32bitLE_to_32bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  sint32_t sval;
  sint32_t dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 4;
  dstflen -= nchannels * 4;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 4, dst += 4)
    {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // read integer sample directly
      sval = const_mem(sint32_t, src);
#else
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[3]) << 24) + (cast(uint32_t, src[2]) << 16) + (cast(uint32_t, src[1]) << 8) + (cast(uint32_t, src[0]));
#endif
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // write integer sample directly
      mem(sint32_t, dst) = sval;
#else
      // write sample bytes to destination
      dst[0] = cast(uint8_t, sval >> 24);
      dst[1] = cast(uint8_t, sval >> 16);
      dst[2] = cast(uint8_t, sval >> 8);
      dst[3] = cast(uint8_t, sval);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 32bit (LE) samples to Float (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_32bitLE_to_FloatBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const float factor = cast(float, pow(2.0, -31.0));
  sint32_t sval;
  float    dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // destination samples are bigger -> start from end of frame and work backwards
  src += nchannels * 4 - 4;
  dst += nchannels * 4 - 4;

  // adjust frame increments for effects of for-loop
  srcflen += nchannels * 4;
  dstflen += nchannels * 4;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src -= 4, dst -= 4)
    {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // read integer sample directly
      sval = const_mem(sint32_t, src);
#else
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[3]) << 24) + (cast(uint32_t, src[2]) << 16) + (cast(uint32_t, src[1]) << 8) + (cast(uint32_t, src[0]));
#endif
      // convert integer sample to floating point sample (scale)
      dval = cast(float, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // write floating point sample directly
      mem(float, dst) = dval;
#else
      // write sample bytes to destination
      dst[0] = cast(uint8_t, dvp[0] >> 24);
      dst[1] = cast(uint8_t, dvp[0] >> 16);
      dst[2] = cast(uint8_t, dvp[0] >> 8);
      dst[3] = cast(uint8_t, dvp[0]);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 32bit (LE) samples to Double (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_32bitLE_to_DoubleBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const double factor = cast(double, pow(2.0, -31.0));
  sint32_t sval;
  double   dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint64_t *dvp = (uint64_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // destination samples are bigger -> start from end of frame and work backwards
  src += nchannels * 4 - 4;
  dst += nchannels * 8 - 8;

  // adjust frame increments for effects of for-loop
  srcflen += nchannels * 4;
  dstflen += nchannels * 8;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src -= 4, dst -= 8)
    {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // read integer sample directly
      sval = const_mem(sint32_t, src);
#else
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[3]) << 24) + (cast(uint32_t, src[2]) << 16) + (cast(uint32_t, src[1]) << 8) + (cast(uint32_t, src[0]));
#endif
      // convert integer sample to floating point sample (scale)
      dval = cast(double, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // write floating point sample directly
      mem(double, dst) = dval;
#else
      // write sample bytes to destination
      dst[0] = cast(uint8_t, dvp[0] >> 56);
      dst[1] = cast(uint8_t, dvp[0] >> 48);
      dst[2] = cast(uint8_t, dvp[0] >> 40);
      dst[3] = cast(uint8_t, dvp[0] >> 32);
      dst[4] = cast(uint8_t, dvp[0] >> 24);
      dst[5] = cast(uint8_t, dvp[0] >> 16);
      dst[6] = cast(uint8_t, dvp[0] >> 8);
      dst[7] = cast(uint8_t, dvp[0]);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert Float (LE) samples to 16bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_FloatLE_to_16bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const double factor = pow(2.0, 31.0);
  float    sval;
  sint32_t dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 4;
  dstflen -= nchannels * 2;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 4, dst += 2)
    {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // read floating point sample directly
      sval = const_mem(float, src);
#else
      // read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
      svp[0] = (cast(uint32_t, src[3]) << 24) + (cast(uint32_t, src[2]) << 16) + (cast(uint32_t, src[1]) << 8) + (cast(uint32_t, src[0]));
#endif
      // apply dither
      if (ditherer) ditherer->Dither(i, sval, 16);
      // convert floating point sample to integer sample (scale and limit)
      dval = cast(sint32_t, limited::limit(sval * factor, -2147483648.0, 2147483647.0));
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // write 16-bit integer sample directly
      mem(sint16_t, dst) = cast(sint16_t, dval >> 16);
#else
      // write sample bytes to destination
      dst[0] = cast(uint8_t, dvp[0] >> 24);
      dst[1] = cast(uint8_t, dvp[0] >> 16);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert Float (LE) samples to 24bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_FloatLE_to_24bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const double factor = pow(2.0, 31.0);
  float    sval;
  sint32_t dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 4;
  dstflen -= nchannels * 3;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 4, dst += 3)
    {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // read floating point sample directly
      sval = const_mem(float, src);
#else
      // read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
      svp[0] = (cast(uint32_t, src[3]) << 24) + (cast(uint32_t, src[2]) << 16) + (cast(uint32_t, src[1]) << 8) + (cast(uint32_t, src[0]));
#endif
      // apply dither
      if (ditherer) ditherer->Dither(i, sval, 8);
      // convert floating point sample to integer sample (scale and limit)
      dval = cast(sint32_t, limited::limit(sval * factor, -2147483648.0, 2147483647.0));
      // write sample bytes to destination
      dst[0] = cast(uint8_t, dvp[0] >> 24);
      dst[1] = cast(uint8_t, dvp[0] >> 16);
      dst[2] = cast(uint8_t, dvp[0] >> 8);
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert Float (LE) samples to 32bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_FloatLE_to_32bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const double factor = pow(2.0, 31.0);
  float    sval;
  sint32_t dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 4;
  dstflen -= nchannels * 4;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 4, dst += 4)
    {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // read floating point sample directly
      sval = const_mem(float, src);
#else
      // read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
      svp[0] = (cast(uint32_t, src[3]) << 24) + (cast(uint32_t, src[2]) << 16) + (cast(uint32_t, src[1]) << 8) + (cast(uint32_t, src[0]));
#endif
      // convert floating point sample to integer sample (scale and limit)
      dval = cast(sint32_t, limited::limit(sval * factor, -2147483648.0, 2147483647.0));
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // write integer sample directly
      mem(sint32_t, dst) = dval;
#else
      // write sample bytes to destination
      dst[0] = cast(uint8_t, dvp[0] >> 24);
      dst[1] = cast(uint8_t, dvp[0] >> 16);
      dst[2] = cast(uint8_t, dvp[0] >> 8);
      dst[3] = cast(uint8_t, dvp[0]);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert Float (LE) samples to Float (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_FloatLE_to_FloatBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  float    sval;
  float    dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 4;
  dstflen -= nchannels * 4;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 4, dst += 4)
    {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // read floating point sample directly
      sval = const_mem(float, src);
#else
      // read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
      svp[0] = (cast(uint32_t, src[3]) << 24) + (cast(uint32_t, src[2]) << 16) + (cast(uint32_t, src[1]) << 8) + (cast(uint32_t, src[0]));
#endif
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // write floating point sample directly
      mem(float, dst) = sval;
#else
      // write sample bytes to destination
      dst[0] = cast(uint8_t, svp[0] >> 24);
      dst[1] = cast(uint8_t, svp[0] >> 16);
      dst[2] = cast(uint8_t, svp[0] >> 8);
      dst[3] = cast(uint8_t, svp[0]);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert Float (LE) samples to Double (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_FloatLE_to_DoubleBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  float    sval;
  double   dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint64_t *dvp = (uint64_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // destination samples are bigger -> start from end of frame and work backwards
  src += nchannels * 4 - 4;
  dst += nchannels * 8 - 8;

  // adjust frame increments for effects of for-loop
  srcflen += nchannels * 4;
  dstflen += nchannels * 8;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src -= 4, dst -= 8)
    {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // read floating point sample directly
      sval = const_mem(float, src);
#else
      // read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
      svp[0] = (cast(uint32_t, src[3]) << 24) + (cast(uint32_t, src[2]) << 16) + (cast(uint32_t, src[1]) << 8) + (cast(uint32_t, src[0]));
#endif
      // convert one type of floating point sample to another
      dval = cast(double, sval);
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // write floating point sample directly
      mem(double, dst) = dval;
#else
      // write sample bytes to destination
      dst[0] = cast(uint8_t, dvp[0] >> 56);
      dst[1] = cast(uint8_t, dvp[0] >> 48);
      dst[2] = cast(uint8_t, dvp[0] >> 40);
      dst[3] = cast(uint8_t, dvp[0] >> 32);
      dst[4] = cast(uint8_t, dvp[0] >> 24);
      dst[5] = cast(uint8_t, dvp[0] >> 16);
      dst[6] = cast(uint8_t, dvp[0] >> 8);
      dst[7] = cast(uint8_t, dvp[0]);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert Double (LE) samples to 16bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_DoubleLE_to_16bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const double factor = pow(2.0, 31.0);
  double   sval;
  sint32_t dval;
  uint64_t *svp = (uint64_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 8;
  dstflen -= nchannels * 2;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 8, dst += 2)
    {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // read floating point sample directly
      sval = const_mem(double, src);
#else
      // read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
      svp[0] = (cast(uint64_t, src[7]) << 56) + (cast(uint64_t, src[6]) << 48) + (cast(uint64_t, src[5]) << 40) + (cast(uint64_t, src[4]) << 32) + (cast(uint64_t, src[3]) << 24) + (cast(uint64_t, src[2]) << 16) + (cast(uint64_t, src[1]) << 8) + (cast(uint64_t, src[0]));
#endif
      // apply dither
      if (ditherer) ditherer->Dither(i, sval, 16);
      // convert floating point sample to integer sample (scale and limit)
      dval = cast(sint32_t, limited::limit(sval * factor, -2147483648.0, 2147483647.0));
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // write 16-bit integer sample directly
      mem(sint16_t, dst) = cast(sint16_t, dval >> 16);
#else
      // write sample bytes to destination
      dst[0] = cast(uint8_t, dvp[0] >> 24);
      dst[1] = cast(uint8_t, dvp[0] >> 16);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert Double (LE) samples to 24bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_DoubleLE_to_24bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const double factor = pow(2.0, 31.0);
  double   sval;
  sint32_t dval;
  uint64_t *svp = (uint64_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 8;
  dstflen -= nchannels * 3;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 8, dst += 3)
    {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // read floating point sample directly
      sval = const_mem(double, src);
#else
      // read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
      svp[0] = (cast(uint64_t, src[7]) << 56) + (cast(uint64_t, src[6]) << 48) + (cast(uint64_t, src[5]) << 40) + (cast(uint64_t, src[4]) << 32) + (cast(uint64_t, src[3]) << 24) + (cast(uint64_t, src[2]) << 16) + (cast(uint64_t, src[1]) << 8) + (cast(uint64_t, src[0]));
#endif
      // apply dither
      if (ditherer) ditherer->Dither(i, sval, 8);
      // convert floating point sample to integer sample (scale and limit)
      dval = cast(sint32_t, limited::limit(sval * factor, -2147483648.0, 2147483647.0));
      // write sample bytes to destination
      dst[0] = cast(uint8_t, dvp[0] >> 24);
      dst[1] = cast(uint8_t, dvp[0] >> 16);
      dst[2] = cast(uint8_t, dvp[0] >> 8);
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert Double (LE) samples to 32bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_DoubleLE_to_32bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const double factor = pow(2.0, 31.0);
  double   sval;
  sint32_t dval;
  uint64_t *svp = (uint64_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 8;
  dstflen -= nchannels * 4;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 8, dst += 4)
    {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // read floating point sample directly
      sval = const_mem(double, src);
#else
      // read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
      svp[0] = (cast(uint64_t, src[7]) << 56) + (cast(uint64_t, src[6]) << 48) + (cast(uint64_t, src[5]) << 40) + (cast(uint64_t, src[4]) << 32) + (cast(uint64_t, src[3]) << 24) + (cast(uint64_t, src[2]) << 16) + (cast(uint64_t, src[1]) << 8) + (cast(uint64_t, src[0]));
#endif
      // apply dither
      if (ditherer) ditherer->Dither(i, sval, 0);
      // convert floating point sample to integer sample (scale and limit)
      dval = cast(sint32_t, limited::limit(sval * factor, -2147483648.0, 2147483647.0));
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // write integer sample directly
      mem(sint32_t, dst) = dval;
#else
      // write sample bytes to destination
      dst[0] = cast(uint8_t, dvp[0] >> 24);
      dst[1] = cast(uint8_t, dvp[0] >> 16);
      dst[2] = cast(uint8_t, dvp[0] >> 8);
      dst[3] = cast(uint8_t, dvp[0]);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert Double (LE) samples to Float (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_DoubleLE_to_FloatBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  double   sval;
  float    dval;
  uint64_t *svp = (uint64_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 8;
  dstflen -= nchannels * 4;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 8, dst += 4)
    {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // read floating point sample directly
      sval = const_mem(double, src);
#else
      // read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
      svp[0] = (cast(uint64_t, src[7]) << 56) + (cast(uint64_t, src[6]) << 48) + (cast(uint64_t, src[5]) << 40) + (cast(uint64_t, src[4]) << 32) + (cast(uint64_t, src[3]) << 24) + (cast(uint64_t, src[2]) << 16) + (cast(uint64_t, src[1]) << 8) + (cast(uint64_t, src[0]));
#endif
      // convert one type of floating point sample to another
      dval = cast(float, sval);
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // write floating point sample directly
      mem(float, dst) = dval;
#else
      // write sample bytes to destination
      dst[0] = cast(uint8_t, dvp[0] >> 24);
      dst[1] = cast(uint8_t, dvp[0] >> 16);
      dst[2] = cast(uint8_t, dvp[0] >> 8);
      dst[3] = cast(uint8_t, dvp[0]);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert Double (LE) samples to Double (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_DoubleLE_to_DoubleBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  double   sval;
  double   dval;
  uint64_t *svp = (uint64_t *)&sval;
  uint64_t *dvp = (uint64_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 8;
  dstflen -= nchannels * 8;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 8, dst += 8)
    {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // read floating point sample directly
      sval = const_mem(double, src);
#else
      // read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
      svp[0] = (cast(uint64_t, src[7]) << 56) + (cast(uint64_t, src[6]) << 48) + (cast(uint64_t, src[5]) << 40) + (cast(uint64_t, src[4]) << 32) + (cast(uint64_t, src[3]) << 24) + (cast(uint64_t, src[2]) << 16) + (cast(uint64_t, src[1]) << 8) + (cast(uint64_t, src[0]));
#endif
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // write floating point sample directly
      mem(double, dst) = sval;
#else
      // write sample bytes to destination
      dst[0] = cast(uint8_t, svp[0] >> 56);
      dst[1] = cast(uint8_t, svp[0] >> 48);
      dst[2] = cast(uint8_t, svp[0] >> 40);
      dst[3] = cast(uint8_t, svp[0] >> 32);
      dst[4] = cast(uint8_t, svp[0] >> 24);
      dst[5] = cast(uint8_t, svp[0] >> 16);
      dst[6] = cast(uint8_t, svp[0] >> 8);
      dst[7] = cast(uint8_t, svp[0]);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 16bit (BE) samples to 16bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_16bitBE_to_16bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  sint32_t sval;
  sint32_t dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 2;
  dstflen -= nchannels * 2;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 2, dst += 2)
    {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // read 16-bit sample and convert to 32-bit sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = cast(uint32_t, const_mem(sint16_t, src) << 16);
#else
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16);
#endif
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // write 16-bit integer sample directly
      mem(sint16_t, dst) = cast(sint16_t, sval >> 16);
#else
      // write sample bytes to destination
      dst[1] = cast(uint8_t, sval >> 24);
      dst[0] = cast(uint8_t, sval >> 16);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 16bit (BE) samples to 24bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_16bitBE_to_24bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  sint32_t sval;
  sint32_t dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // destination samples are bigger -> start from end of frame and work backwards
  src += nchannels * 2 - 2;
  dst += nchannels * 3 - 3;

  // adjust frame increments for effects of for-loop
  srcflen += nchannels * 2;
  dstflen += nchannels * 3;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src -= 2, dst -= 3)
    {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // read 16-bit sample and convert to 32-bit sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = cast(uint32_t, const_mem(sint16_t, src) << 16);
#else
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16);
#endif
      // write sample bytes to destination
      dst[2] = cast(uint8_t, sval >> 24);
      dst[1] = cast(uint8_t, sval >> 16);
      dst[0] = cast(uint8_t, sval >> 8);
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 16bit (BE) samples to 32bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_16bitBE_to_32bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  sint32_t sval;
  sint32_t dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // destination samples are bigger -> start from end of frame and work backwards
  src += nchannels * 2 - 2;
  dst += nchannels * 4 - 4;

  // adjust frame increments for effects of for-loop
  srcflen += nchannels * 2;
  dstflen += nchannels * 4;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src -= 2, dst -= 4)
    {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // read 16-bit sample and convert to 32-bit sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = cast(uint32_t, const_mem(sint16_t, src) << 16);
#else
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16);
#endif
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // write integer sample directly
      mem(sint32_t, dst) = sval;
#else
      // write sample bytes to destination
      dst[3] = cast(uint8_t, sval >> 24);
      dst[2] = cast(uint8_t, sval >> 16);
      dst[1] = cast(uint8_t, sval >> 8);
      dst[0] = cast(uint8_t, sval);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 16bit (BE) samples to Float (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_16bitBE_to_FloatLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const float factor = cast(float, pow(2.0, -31.0));
  sint32_t sval;
  float    dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // destination samples are bigger -> start from end of frame and work backwards
  src += nchannels * 2 - 2;
  dst += nchannels * 4 - 4;

  // adjust frame increments for effects of for-loop
  srcflen += nchannels * 2;
  dstflen += nchannels * 4;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src -= 2, dst -= 4)
    {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // read 16-bit sample and convert to 32-bit sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = cast(uint32_t, const_mem(sint16_t, src) << 16);
#else
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16);
#endif
      // convert integer sample to floating point sample (scale)
      dval = cast(float, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // write floating point sample directly
      mem(float, dst) = dval;
#else
      // write sample bytes to destination
      dst[3] = cast(uint8_t, dvp[0] >> 24);
      dst[2] = cast(uint8_t, dvp[0] >> 16);
      dst[1] = cast(uint8_t, dvp[0] >> 8);
      dst[0] = cast(uint8_t, dvp[0]);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 16bit (BE) samples to Double (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_16bitBE_to_DoubleLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const double factor = cast(double, pow(2.0, -31.0));
  sint32_t sval;
  double   dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint64_t *dvp = (uint64_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // destination samples are bigger -> start from end of frame and work backwards
  src += nchannels * 2 - 2;
  dst += nchannels * 8 - 8;

  // adjust frame increments for effects of for-loop
  srcflen += nchannels * 2;
  dstflen += nchannels * 8;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src -= 2, dst -= 8)
    {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // read 16-bit sample and convert to 32-bit sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = cast(uint32_t, const_mem(sint16_t, src) << 16);
#else
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16);
#endif
      // convert integer sample to floating point sample (scale)
      dval = cast(double, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // write floating point sample directly
      mem(double, dst) = dval;
#else
      // write sample bytes to destination
      dst[7] = cast(uint8_t, dvp[0] >> 56);
      dst[6] = cast(uint8_t, dvp[0] >> 48);
      dst[5] = cast(uint8_t, dvp[0] >> 40);
      dst[4] = cast(uint8_t, dvp[0] >> 32);
      dst[3] = cast(uint8_t, dvp[0] >> 24);
      dst[2] = cast(uint8_t, dvp[0] >> 16);
      dst[1] = cast(uint8_t, dvp[0] >> 8);
      dst[0] = cast(uint8_t, dvp[0]);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 24bit (BE) samples to 16bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_24bitBE_to_16bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  sint32_t sval;
  sint32_t dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 3;
  dstflen -= nchannels * 2;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 3, dst += 2)
    {
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8);
      // apply dither
      if (ditherer) ditherer->Dither(i, sval, 16);
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // write 16-bit integer sample directly
      mem(sint16_t, dst) = cast(sint16_t, sval >> 16);
#else
      // write sample bytes to destination
      dst[1] = cast(uint8_t, sval >> 24);
      dst[0] = cast(uint8_t, sval >> 16);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 24bit (BE) samples to 24bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_24bitBE_to_24bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  sint32_t sval;
  sint32_t dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 3;
  dstflen -= nchannels * 3;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 3, dst += 3)
    {
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8);
      // write sample bytes to destination
      dst[2] = cast(uint8_t, sval >> 24);
      dst[1] = cast(uint8_t, sval >> 16);
      dst[0] = cast(uint8_t, sval >> 8);
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 24bit (BE) samples to 32bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_24bitBE_to_32bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  sint32_t sval;
  sint32_t dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // destination samples are bigger -> start from end of frame and work backwards
  src += nchannels * 3 - 3;
  dst += nchannels * 4 - 4;

  // adjust frame increments for effects of for-loop
  srcflen += nchannels * 3;
  dstflen += nchannels * 4;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src -= 3, dst -= 4)
    {
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8);
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // write integer sample directly
      mem(sint32_t, dst) = sval;
#else
      // write sample bytes to destination
      dst[3] = cast(uint8_t, sval >> 24);
      dst[2] = cast(uint8_t, sval >> 16);
      dst[1] = cast(uint8_t, sval >> 8);
      dst[0] = cast(uint8_t, sval);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 24bit (BE) samples to Float (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_24bitBE_to_FloatLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const float factor = cast(float, pow(2.0, -31.0));
  sint32_t sval;
  float    dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // destination samples are bigger -> start from end of frame and work backwards
  src += nchannels * 3 - 3;
  dst += nchannels * 4 - 4;

  // adjust frame increments for effects of for-loop
  srcflen += nchannels * 3;
  dstflen += nchannels * 4;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src -= 3, dst -= 4)
    {
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8);
      // convert integer sample to floating point sample (scale)
      dval = cast(float, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // write floating point sample directly
      mem(float, dst) = dval;
#else
      // write sample bytes to destination
      dst[3] = cast(uint8_t, dvp[0] >> 24);
      dst[2] = cast(uint8_t, dvp[0] >> 16);
      dst[1] = cast(uint8_t, dvp[0] >> 8);
      dst[0] = cast(uint8_t, dvp[0]);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 24bit (BE) samples to Double (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_24bitBE_to_DoubleLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const double factor = cast(double, pow(2.0, -31.0));
  sint32_t sval;
  double   dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint64_t *dvp = (uint64_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // destination samples are bigger -> start from end of frame and work backwards
  src += nchannels * 3 - 3;
  dst += nchannels * 8 - 8;

  // adjust frame increments for effects of for-loop
  srcflen += nchannels * 3;
  dstflen += nchannels * 8;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src -= 3, dst -= 8)
    {
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8);
      // convert integer sample to floating point sample (scale)
      dval = cast(double, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // write floating point sample directly
      mem(double, dst) = dval;
#else
      // write sample bytes to destination
      dst[7] = cast(uint8_t, dvp[0] >> 56);
      dst[6] = cast(uint8_t, dvp[0] >> 48);
      dst[5] = cast(uint8_t, dvp[0] >> 40);
      dst[4] = cast(uint8_t, dvp[0] >> 32);
      dst[3] = cast(uint8_t, dvp[0] >> 24);
      dst[2] = cast(uint8_t, dvp[0] >> 16);
      dst[1] = cast(uint8_t, dvp[0] >> 8);
      dst[0] = cast(uint8_t, dvp[0]);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 32bit (BE) samples to 16bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_32bitBE_to_16bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  sint32_t sval;
  sint32_t dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 4;
  dstflen -= nchannels * 2;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 4, dst += 2)
    {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // read integer sample directly
      sval = const_mem(sint32_t, src);
#else
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8) + (cast(uint32_t, src[3]));
#endif
      // apply dither
      if (ditherer) ditherer->Dither(i, sval, 16);
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // write 16-bit integer sample directly
      mem(sint16_t, dst) = cast(sint16_t, sval >> 16);
#else
      // write sample bytes to destination
      dst[1] = cast(uint8_t, sval >> 24);
      dst[0] = cast(uint8_t, sval >> 16);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 32bit (BE) samples to 24bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_32bitBE_to_24bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  sint32_t sval;
  sint32_t dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 4;
  dstflen -= nchannels * 3;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 4, dst += 3)
    {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // read integer sample directly
      sval = const_mem(sint32_t, src);
#else
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8) + (cast(uint32_t, src[3]));
#endif
      // apply dither
      if (ditherer) ditherer->Dither(i, sval, 8);
      // write sample bytes to destination
      dst[2] = cast(uint8_t, sval >> 24);
      dst[1] = cast(uint8_t, sval >> 16);
      dst[0] = cast(uint8_t, sval >> 8);
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 32bit (BE) samples to 32bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_32bitBE_to_32bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  sint32_t sval;
  sint32_t dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 4;
  dstflen -= nchannels * 4;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 4, dst += 4)
    {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // read integer sample directly
      sval = const_mem(sint32_t, src);
#else
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8) + (cast(uint32_t, src[3]));
#endif
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // write integer sample directly
      mem(sint32_t, dst) = sval;
#else
      // write sample bytes to destination
      dst[3] = cast(uint8_t, sval >> 24);
      dst[2] = cast(uint8_t, sval >> 16);
      dst[1] = cast(uint8_t, sval >> 8);
      dst[0] = cast(uint8_t, sval);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 32bit (BE) samples to Float (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_32bitBE_to_FloatLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const float factor = cast(float, pow(2.0, -31.0));
  sint32_t sval;
  float    dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // destination samples are bigger -> start from end of frame and work backwards
  src += nchannels * 4 - 4;
  dst += nchannels * 4 - 4;

  // adjust frame increments for effects of for-loop
  srcflen += nchannels * 4;
  dstflen += nchannels * 4;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src -= 4, dst -= 4)
    {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // read integer sample directly
      sval = const_mem(sint32_t, src);
#else
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8) + (cast(uint32_t, src[3]));
#endif
      // convert integer sample to floating point sample (scale)
      dval = cast(float, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // write floating point sample directly
      mem(float, dst) = dval;
#else
      // write sample bytes to destination
      dst[3] = cast(uint8_t, dvp[0] >> 24);
      dst[2] = cast(uint8_t, dvp[0] >> 16);
      dst[1] = cast(uint8_t, dvp[0] >> 8);
      dst[0] = cast(uint8_t, dvp[0]);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 32bit (BE) samples to Double (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_32bitBE_to_DoubleLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const double factor = cast(double, pow(2.0, -31.0));
  sint32_t sval;
  double   dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint64_t *dvp = (uint64_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // destination samples are bigger -> start from end of frame and work backwards
  src += nchannels * 4 - 4;
  dst += nchannels * 8 - 8;

  // adjust frame increments for effects of for-loop
  srcflen += nchannels * 4;
  dstflen += nchannels * 8;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src -= 4, dst -= 8)
    {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // read integer sample directly
      sval = const_mem(sint32_t, src);
#else
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8) + (cast(uint32_t, src[3]));
#endif
      // convert integer sample to floating point sample (scale)
      dval = cast(double, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // write floating point sample directly
      mem(double, dst) = dval;
#else
      // write sample bytes to destination
      dst[7] = cast(uint8_t, dvp[0] >> 56);
      dst[6] = cast(uint8_t, dvp[0] >> 48);
      dst[5] = cast(uint8_t, dvp[0] >> 40);
      dst[4] = cast(uint8_t, dvp[0] >> 32);
      dst[3] = cast(uint8_t, dvp[0] >> 24);
      dst[2] = cast(uint8_t, dvp[0] >> 16);
      dst[1] = cast(uint8_t, dvp[0] >> 8);
      dst[0] = cast(uint8_t, dvp[0]);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert Float (BE) samples to 16bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_FloatBE_to_16bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const double factor = pow(2.0, 31.0);
  float    sval;
  sint32_t dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 4;
  dstflen -= nchannels * 2;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 4, dst += 2)
    {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // read floating point sample directly
      sval = const_mem(float, src);
#else
      // read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
      svp[0] = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8) + (cast(uint32_t, src[3]));
#endif
      // apply dither
      if (ditherer) ditherer->Dither(i, sval, 16);
      // convert floating point sample to integer sample (scale and limit)
      dval = cast(sint32_t, limited::limit(sval * factor, -2147483648.0, 2147483647.0));
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // write 16-bit integer sample directly
      mem(sint16_t, dst) = cast(sint16_t, dval >> 16);
#else
      // write sample bytes to destination
      dst[1] = cast(uint8_t, dvp[0] >> 24);
      dst[0] = cast(uint8_t, dvp[0] >> 16);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert Float (BE) samples to 24bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_FloatBE_to_24bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const double factor = pow(2.0, 31.0);
  float    sval;
  sint32_t dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 4;
  dstflen -= nchannels * 3;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 4, dst += 3)
    {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // read floating point sample directly
      sval = const_mem(float, src);
#else
      // read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
      svp[0] = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8) + (cast(uint32_t, src[3]));
#endif
      // apply dither
      if (ditherer) ditherer->Dither(i, sval, 8);
      // convert floating point sample to integer sample (scale and limit)
      dval = cast(sint32_t, limited::limit(sval * factor, -2147483648.0, 2147483647.0));
      // write sample bytes to destination
      dst[2] = cast(uint8_t, dvp[0] >> 24);
      dst[1] = cast(uint8_t, dvp[0] >> 16);
      dst[0] = cast(uint8_t, dvp[0] >> 8);
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert Float (BE) samples to 32bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_FloatBE_to_32bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const double factor = pow(2.0, 31.0);
  float    sval;
  sint32_t dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 4;
  dstflen -= nchannels * 4;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 4, dst += 4)
    {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // read floating point sample directly
      sval = const_mem(float, src);
#else
      // read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
      svp[0] = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8) + (cast(uint32_t, src[3]));
#endif
      // convert floating point sample to integer sample (scale and limit)
      dval = cast(sint32_t, limited::limit(sval * factor, -2147483648.0, 2147483647.0));
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // write integer sample directly
      mem(sint32_t, dst) = dval;
#else
      // write sample bytes to destination
      dst[3] = cast(uint8_t, dvp[0] >> 24);
      dst[2] = cast(uint8_t, dvp[0] >> 16);
      dst[1] = cast(uint8_t, dvp[0] >> 8);
      dst[0] = cast(uint8_t, dvp[0]);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert Float (BE) samples to Float (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_FloatBE_to_FloatLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  float    sval;
  float    dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 4;
  dstflen -= nchannels * 4;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 4, dst += 4)
    {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // read floating point sample directly
      sval = const_mem(float, src);
#else
      // read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
      svp[0] = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8) + (cast(uint32_t, src[3]));
#endif
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // write floating point sample directly
      mem(float, dst) = sval;
#else
      // write sample bytes to destination
      dst[3] = cast(uint8_t, svp[0] >> 24);
      dst[2] = cast(uint8_t, svp[0] >> 16);
      dst[1] = cast(uint8_t, svp[0] >> 8);
      dst[0] = cast(uint8_t, svp[0]);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert Float (BE) samples to Double (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_FloatBE_to_DoubleLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  float    sval;
  double   dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint64_t *dvp = (uint64_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // destination samples are bigger -> start from end of frame and work backwards
  src += nchannels * 4 - 4;
  dst += nchannels * 8 - 8;

  // adjust frame increments for effects of for-loop
  srcflen += nchannels * 4;
  dstflen += nchannels * 8;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src -= 4, dst -= 8)
    {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // read floating point sample directly
      sval = const_mem(float, src);
#else
      // read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
      svp[0] = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8) + (cast(uint32_t, src[3]));
#endif
      // convert one type of floating point sample to another
      dval = cast(double, sval);
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // write floating point sample directly
      mem(double, dst) = dval;
#else
      // write sample bytes to destination
      dst[7] = cast(uint8_t, dvp[0] >> 56);
      dst[6] = cast(uint8_t, dvp[0] >> 48);
      dst[5] = cast(uint8_t, dvp[0] >> 40);
      dst[4] = cast(uint8_t, dvp[0] >> 32);
      dst[3] = cast(uint8_t, dvp[0] >> 24);
      dst[2] = cast(uint8_t, dvp[0] >> 16);
      dst[1] = cast(uint8_t, dvp[0] >> 8);
      dst[0] = cast(uint8_t, dvp[0]);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert Double (BE) samples to 16bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_DoubleBE_to_16bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const double factor = pow(2.0, 31.0);
  double   sval;
  sint32_t dval;
  uint64_t *svp = (uint64_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 8;
  dstflen -= nchannels * 2;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 8, dst += 2)
    {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // read floating point sample directly
      sval = const_mem(double, src);
#else
      // read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
      svp[0] = (cast(uint64_t, src[0]) << 56) + (cast(uint64_t, src[1]) << 48) + (cast(uint64_t, src[2]) << 40) + (cast(uint64_t, src[3]) << 32) + (cast(uint64_t, src[4]) << 24) + (cast(uint64_t, src[5]) << 16) + (cast(uint64_t, src[6]) << 8) + (cast(uint64_t, src[7]));
#endif
      // apply dither
      if (ditherer) ditherer->Dither(i, sval, 16);
      // convert floating point sample to integer sample (scale and limit)
      dval = cast(sint32_t, limited::limit(sval * factor, -2147483648.0, 2147483647.0));
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // write 16-bit integer sample directly
      mem(sint16_t, dst) = cast(sint16_t, dval >> 16);
#else
      // write sample bytes to destination
      dst[1] = cast(uint8_t, dvp[0] >> 24);
      dst[0] = cast(uint8_t, dvp[0] >> 16);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert Double (BE) samples to 24bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_DoubleBE_to_24bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const double factor = pow(2.0, 31.0);
  double   sval;
  sint32_t dval;
  uint64_t *svp = (uint64_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 8;
  dstflen -= nchannels * 3;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 8, dst += 3)
    {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // read floating point sample directly
      sval = const_mem(double, src);
#else
      // read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
      svp[0] = (cast(uint64_t, src[0]) << 56) + (cast(uint64_t, src[1]) << 48) + (cast(uint64_t, src[2]) << 40) + (cast(uint64_t, src[3]) << 32) + (cast(uint64_t, src[4]) << 24) + (cast(uint64_t, src[5]) << 16) + (cast(uint64_t, src[6]) << 8) + (cast(uint64_t, src[7]));
#endif
      // apply dither
      if (ditherer) ditherer->Dither(i, sval, 8);
      // convert floating point sample to integer sample (scale and limit)
      dval = cast(sint32_t, limited::limit(sval * factor, -2147483648.0, 2147483647.0));
      // write sample bytes to destination
      dst[2] = cast(uint8_t, dvp[0] >> 24);
      dst[1] = cast(uint8_t, dvp[0] >> 16);
      dst[0] = cast(uint8_t, dvp[0] >> 8);
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert Double (BE) samples to 32bit (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_DoubleBE_to_32bitLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const double factor = pow(2.0, 31.0);
  double   sval;
  sint32_t dval;
  uint64_t *svp = (uint64_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 8;
  dstflen -= nchannels * 4;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 8, dst += 4)
    {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // read floating point sample directly
      sval = const_mem(double, src);
#else
      // read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
      svp[0] = (cast(uint64_t, src[0]) << 56) + (cast(uint64_t, src[1]) << 48) + (cast(uint64_t, src[2]) << 40) + (cast(uint64_t, src[3]) << 32) + (cast(uint64_t, src[4]) << 24) + (cast(uint64_t, src[5]) << 16) + (cast(uint64_t, src[6]) << 8) + (cast(uint64_t, src[7]));
#endif
      // apply dither
      if (ditherer) ditherer->Dither(i, sval, 0);
      // convert floating point sample to integer sample (scale and limit)
      dval = cast(sint32_t, limited::limit(sval * factor, -2147483648.0, 2147483647.0));
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // write integer sample directly
      mem(sint32_t, dst) = dval;
#else
      // write sample bytes to destination
      dst[3] = cast(uint8_t, dvp[0] >> 24);
      dst[2] = cast(uint8_t, dvp[0] >> 16);
      dst[1] = cast(uint8_t, dvp[0] >> 8);
      dst[0] = cast(uint8_t, dvp[0]);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert Double (BE) samples to Float (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_DoubleBE_to_FloatLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  double   sval;
  float    dval;
  uint64_t *svp = (uint64_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 8;
  dstflen -= nchannels * 4;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 8, dst += 4)
    {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // read floating point sample directly
      sval = const_mem(double, src);
#else
      // read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
      svp[0] = (cast(uint64_t, src[0]) << 56) + (cast(uint64_t, src[1]) << 48) + (cast(uint64_t, src[2]) << 40) + (cast(uint64_t, src[3]) << 32) + (cast(uint64_t, src[4]) << 24) + (cast(uint64_t, src[5]) << 16) + (cast(uint64_t, src[6]) << 8) + (cast(uint64_t, src[7]));
#endif
      // convert one type of floating point sample to another
      dval = cast(float, sval);
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // write floating point sample directly
      mem(float, dst) = dval;
#else
      // write sample bytes to destination
      dst[3] = cast(uint8_t, dvp[0] >> 24);
      dst[2] = cast(uint8_t, dvp[0] >> 16);
      dst[1] = cast(uint8_t, dvp[0] >> 8);
      dst[0] = cast(uint8_t, dvp[0]);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert Double (BE) samples to Double (LE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_DoubleBE_to_DoubleLE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  double   sval;
  double   dval;
  uint64_t *svp = (uint64_t *)&sval;
  uint64_t *dvp = (uint64_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 8;
  dstflen -= nchannels * 8;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 8, dst += 8)
    {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // read floating point sample directly
      sval = const_mem(double, src);
#else
      // read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
      svp[0] = (cast(uint64_t, src[0]) << 56) + (cast(uint64_t, src[1]) << 48) + (cast(uint64_t, src[2]) << 40) + (cast(uint64_t, src[3]) << 32) + (cast(uint64_t, src[4]) << 24) + (cast(uint64_t, src[5]) << 16) + (cast(uint64_t, src[6]) << 8) + (cast(uint64_t, src[7]));
#endif
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      // write floating point sample directly
      mem(double, dst) = sval;
#else
      // write sample bytes to destination
      dst[7] = cast(uint8_t, svp[0] >> 56);
      dst[6] = cast(uint8_t, svp[0] >> 48);
      dst[5] = cast(uint8_t, svp[0] >> 40);
      dst[4] = cast(uint8_t, svp[0] >> 32);
      dst[3] = cast(uint8_t, svp[0] >> 24);
      dst[2] = cast(uint8_t, svp[0] >> 16);
      dst[1] = cast(uint8_t, svp[0] >> 8);
      dst[0] = cast(uint8_t, svp[0]);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 16bit (BE) samples to 24bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_16bitBE_to_24bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  sint32_t sval;
  sint32_t dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // destination samples are bigger -> start from end of frame and work backwards
  src += nchannels * 2 - 2;
  dst += nchannels * 3 - 3;

  // adjust frame increments for effects of for-loop
  srcflen += nchannels * 2;
  dstflen += nchannels * 3;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src -= 2, dst -= 3)
    {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // read 16-bit sample and convert to 32-bit sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = cast(uint32_t, const_mem(sint16_t, src) << 16);
#else
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16);
#endif
      // write sample bytes to destination
      dst[0] = cast(uint8_t, sval >> 24);
      dst[1] = cast(uint8_t, sval >> 16);
      dst[2] = cast(uint8_t, sval >> 8);
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 16bit (BE) samples to 32bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_16bitBE_to_32bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  sint32_t sval;
  sint32_t dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // destination samples are bigger -> start from end of frame and work backwards
  src += nchannels * 2 - 2;
  dst += nchannels * 4 - 4;

  // adjust frame increments for effects of for-loop
  srcflen += nchannels * 2;
  dstflen += nchannels * 4;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src -= 2, dst -= 4)
    {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // read 16-bit sample and convert to 32-bit sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = cast(uint32_t, const_mem(sint16_t, src) << 16);
#else
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16);
#endif
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // write integer sample directly
      mem(sint32_t, dst) = sval;
#else
      // write sample bytes to destination
      dst[0] = cast(uint8_t, sval >> 24);
      dst[1] = cast(uint8_t, sval >> 16);
      dst[2] = cast(uint8_t, sval >> 8);
      dst[3] = cast(uint8_t, sval);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 16bit (BE) samples to Float (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_16bitBE_to_FloatBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const float factor = cast(float, pow(2.0, -31.0));
  sint32_t sval;
  float    dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // destination samples are bigger -> start from end of frame and work backwards
  src += nchannels * 2 - 2;
  dst += nchannels * 4 - 4;

  // adjust frame increments for effects of for-loop
  srcflen += nchannels * 2;
  dstflen += nchannels * 4;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src -= 2, dst -= 4)
    {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // read 16-bit sample and convert to 32-bit sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = cast(uint32_t, const_mem(sint16_t, src) << 16);
#else
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16);
#endif
      // convert integer sample to floating point sample (scale)
      dval = cast(float, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // write floating point sample directly
      mem(float, dst) = dval;
#else
      // write sample bytes to destination
      dst[0] = cast(uint8_t, dvp[0] >> 24);
      dst[1] = cast(uint8_t, dvp[0] >> 16);
      dst[2] = cast(uint8_t, dvp[0] >> 8);
      dst[3] = cast(uint8_t, dvp[0]);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 16bit (BE) samples to Double (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_16bitBE_to_DoubleBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const double factor = cast(double, pow(2.0, -31.0));
  sint32_t sval;
  double   dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint64_t *dvp = (uint64_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // destination samples are bigger -> start from end of frame and work backwards
  src += nchannels * 2 - 2;
  dst += nchannels * 8 - 8;

  // adjust frame increments for effects of for-loop
  srcflen += nchannels * 2;
  dstflen += nchannels * 8;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src -= 2, dst -= 8)
    {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // read 16-bit sample and convert to 32-bit sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = cast(uint32_t, const_mem(sint16_t, src) << 16);
#else
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16);
#endif
      // convert integer sample to floating point sample (scale)
      dval = cast(double, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // write floating point sample directly
      mem(double, dst) = dval;
#else
      // write sample bytes to destination
      dst[0] = cast(uint8_t, dvp[0] >> 56);
      dst[1] = cast(uint8_t, dvp[0] >> 48);
      dst[2] = cast(uint8_t, dvp[0] >> 40);
      dst[3] = cast(uint8_t, dvp[0] >> 32);
      dst[4] = cast(uint8_t, dvp[0] >> 24);
      dst[5] = cast(uint8_t, dvp[0] >> 16);
      dst[6] = cast(uint8_t, dvp[0] >> 8);
      dst[7] = cast(uint8_t, dvp[0]);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 24bit (BE) samples to 16bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_24bitBE_to_16bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  sint32_t sval;
  sint32_t dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 3;
  dstflen -= nchannels * 2;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 3, dst += 2)
    {
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8);
      // apply dither
      if (ditherer) ditherer->Dither(i, sval, 16);
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // write 16-bit integer sample directly
      mem(sint16_t, dst) = cast(sint16_t, sval >> 16);
#else
      // write sample bytes to destination
      dst[0] = cast(uint8_t, sval >> 24);
      dst[1] = cast(uint8_t, sval >> 16);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 24bit (BE) samples to 32bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_24bitBE_to_32bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  sint32_t sval;
  sint32_t dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // destination samples are bigger -> start from end of frame and work backwards
  src += nchannels * 3 - 3;
  dst += nchannels * 4 - 4;

  // adjust frame increments for effects of for-loop
  srcflen += nchannels * 3;
  dstflen += nchannels * 4;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src -= 3, dst -= 4)
    {
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8);
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // write integer sample directly
      mem(sint32_t, dst) = sval;
#else
      // write sample bytes to destination
      dst[0] = cast(uint8_t, sval >> 24);
      dst[1] = cast(uint8_t, sval >> 16);
      dst[2] = cast(uint8_t, sval >> 8);
      dst[3] = cast(uint8_t, sval);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 24bit (BE) samples to Float (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_24bitBE_to_FloatBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const float factor = cast(float, pow(2.0, -31.0));
  sint32_t sval;
  float    dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // destination samples are bigger -> start from end of frame and work backwards
  src += nchannels * 3 - 3;
  dst += nchannels * 4 - 4;

  // adjust frame increments for effects of for-loop
  srcflen += nchannels * 3;
  dstflen += nchannels * 4;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src -= 3, dst -= 4)
    {
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8);
      // convert integer sample to floating point sample (scale)
      dval = cast(float, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // write floating point sample directly
      mem(float, dst) = dval;
#else
      // write sample bytes to destination
      dst[0] = cast(uint8_t, dvp[0] >> 24);
      dst[1] = cast(uint8_t, dvp[0] >> 16);
      dst[2] = cast(uint8_t, dvp[0] >> 8);
      dst[3] = cast(uint8_t, dvp[0]);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 24bit (BE) samples to Double (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_24bitBE_to_DoubleBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const double factor = cast(double, pow(2.0, -31.0));
  sint32_t sval;
  double   dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint64_t *dvp = (uint64_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // destination samples are bigger -> start from end of frame and work backwards
  src += nchannels * 3 - 3;
  dst += nchannels * 8 - 8;

  // adjust frame increments for effects of for-loop
  srcflen += nchannels * 3;
  dstflen += nchannels * 8;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src -= 3, dst -= 8)
    {
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8);
      // convert integer sample to floating point sample (scale)
      dval = cast(double, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // write floating point sample directly
      mem(double, dst) = dval;
#else
      // write sample bytes to destination
      dst[0] = cast(uint8_t, dvp[0] >> 56);
      dst[1] = cast(uint8_t, dvp[0] >> 48);
      dst[2] = cast(uint8_t, dvp[0] >> 40);
      dst[3] = cast(uint8_t, dvp[0] >> 32);
      dst[4] = cast(uint8_t, dvp[0] >> 24);
      dst[5] = cast(uint8_t, dvp[0] >> 16);
      dst[6] = cast(uint8_t, dvp[0] >> 8);
      dst[7] = cast(uint8_t, dvp[0]);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 32bit (BE) samples to 16bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_32bitBE_to_16bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  sint32_t sval;
  sint32_t dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 4;
  dstflen -= nchannels * 2;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 4, dst += 2)
    {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // read integer sample directly
      sval = const_mem(sint32_t, src);
#else
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8) + (cast(uint32_t, src[3]));
#endif
      // apply dither
      if (ditherer) ditherer->Dither(i, sval, 16);
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // write 16-bit integer sample directly
      mem(sint16_t, dst) = cast(sint16_t, sval >> 16);
#else
      // write sample bytes to destination
      dst[0] = cast(uint8_t, sval >> 24);
      dst[1] = cast(uint8_t, sval >> 16);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 32bit (BE) samples to 24bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_32bitBE_to_24bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  sint32_t sval;
  sint32_t dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 4;
  dstflen -= nchannels * 3;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 4, dst += 3)
    {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // read integer sample directly
      sval = const_mem(sint32_t, src);
#else
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8) + (cast(uint32_t, src[3]));
#endif
      // apply dither
      if (ditherer) ditherer->Dither(i, sval, 8);
      // write sample bytes to destination
      dst[0] = cast(uint8_t, sval >> 24);
      dst[1] = cast(uint8_t, sval >> 16);
      dst[2] = cast(uint8_t, sval >> 8);
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 32bit (BE) samples to Float (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_32bitBE_to_FloatBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const float factor = cast(float, pow(2.0, -31.0));
  sint32_t sval;
  float    dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // destination samples are bigger -> start from end of frame and work backwards
  src += nchannels * 4 - 4;
  dst += nchannels * 4 - 4;

  // adjust frame increments for effects of for-loop
  srcflen += nchannels * 4;
  dstflen += nchannels * 4;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src -= 4, dst -= 4)
    {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // read integer sample directly
      sval = const_mem(sint32_t, src);
#else
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8) + (cast(uint32_t, src[3]));
#endif
      // convert integer sample to floating point sample (scale)
      dval = cast(float, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // write floating point sample directly
      mem(float, dst) = dval;
#else
      // write sample bytes to destination
      dst[0] = cast(uint8_t, dvp[0] >> 24);
      dst[1] = cast(uint8_t, dvp[0] >> 16);
      dst[2] = cast(uint8_t, dvp[0] >> 8);
      dst[3] = cast(uint8_t, dvp[0]);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert 32bit (BE) samples to Double (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_32bitBE_to_DoubleBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const double factor = cast(double, pow(2.0, -31.0));
  sint32_t sval;
  double   dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint64_t *dvp = (uint64_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // destination samples are bigger -> start from end of frame and work backwards
  src += nchannels * 4 - 4;
  dst += nchannels * 8 - 8;

  // adjust frame increments for effects of for-loop
  srcflen += nchannels * 4;
  dstflen += nchannels * 8;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src -= 4, dst -= 8)
    {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // read integer sample directly
      sval = const_mem(sint32_t, src);
#else
      // read integer bytes representing integer sample (note use of unsigned arithmetic to avoid problems with left shift)
      sval = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8) + (cast(uint32_t, src[3]));
#endif
      // convert integer sample to floating point sample (scale)
      dval = cast(double, sval) * factor;
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // write floating point sample directly
      mem(double, dst) = dval;
#else
      // write sample bytes to destination
      dst[0] = cast(uint8_t, dvp[0] >> 56);
      dst[1] = cast(uint8_t, dvp[0] >> 48);
      dst[2] = cast(uint8_t, dvp[0] >> 40);
      dst[3] = cast(uint8_t, dvp[0] >> 32);
      dst[4] = cast(uint8_t, dvp[0] >> 24);
      dst[5] = cast(uint8_t, dvp[0] >> 16);
      dst[6] = cast(uint8_t, dvp[0] >> 8);
      dst[7] = cast(uint8_t, dvp[0]);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert Float (BE) samples to 16bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_FloatBE_to_16bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const double factor = pow(2.0, 31.0);
  float    sval;
  sint32_t dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 4;
  dstflen -= nchannels * 2;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 4, dst += 2)
    {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // read floating point sample directly
      sval = const_mem(float, src);
#else
      // read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
      svp[0] = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8) + (cast(uint32_t, src[3]));
#endif
      // apply dither
      if (ditherer) ditherer->Dither(i, sval, 16);
      // convert floating point sample to integer sample (scale and limit)
      dval = cast(sint32_t, limited::limit(sval * factor, -2147483648.0, 2147483647.0));
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // write 16-bit integer sample directly
      mem(sint16_t, dst) = cast(sint16_t, dval >> 16);
#else
      // write sample bytes to destination
      dst[0] = cast(uint8_t, dvp[0] >> 24);
      dst[1] = cast(uint8_t, dvp[0] >> 16);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert Float (BE) samples to 24bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_FloatBE_to_24bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const double factor = pow(2.0, 31.0);
  float    sval;
  sint32_t dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 4;
  dstflen -= nchannels * 3;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 4, dst += 3)
    {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // read floating point sample directly
      sval = const_mem(float, src);
#else
      // read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
      svp[0] = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8) + (cast(uint32_t, src[3]));
#endif
      // apply dither
      if (ditherer) ditherer->Dither(i, sval, 8);
      // convert floating point sample to integer sample (scale and limit)
      dval = cast(sint32_t, limited::limit(sval * factor, -2147483648.0, 2147483647.0));
      // write sample bytes to destination
      dst[0] = cast(uint8_t, dvp[0] >> 24);
      dst[1] = cast(uint8_t, dvp[0] >> 16);
      dst[2] = cast(uint8_t, dvp[0] >> 8);
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert Float (BE) samples to 32bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_FloatBE_to_32bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const double factor = pow(2.0, 31.0);
  float    sval;
  sint32_t dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 4;
  dstflen -= nchannels * 4;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 4, dst += 4)
    {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // read floating point sample directly
      sval = const_mem(float, src);
#else
      // read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
      svp[0] = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8) + (cast(uint32_t, src[3]));
#endif
      // convert floating point sample to integer sample (scale and limit)
      dval = cast(sint32_t, limited::limit(sval * factor, -2147483648.0, 2147483647.0));
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // write integer sample directly
      mem(sint32_t, dst) = dval;
#else
      // write sample bytes to destination
      dst[0] = cast(uint8_t, dvp[0] >> 24);
      dst[1] = cast(uint8_t, dvp[0] >> 16);
      dst[2] = cast(uint8_t, dvp[0] >> 8);
      dst[3] = cast(uint8_t, dvp[0]);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert Float (BE) samples to Double (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_FloatBE_to_DoubleBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  float    sval;
  double   dval;
  uint32_t *svp = (uint32_t *)&sval;
  uint64_t *dvp = (uint64_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // destination samples are bigger -> start from end of frame and work backwards
  src += nchannels * 4 - 4;
  dst += nchannels * 8 - 8;

  // adjust frame increments for effects of for-loop
  srcflen += nchannels * 4;
  dstflen += nchannels * 8;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src -= 4, dst -= 8)
    {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // read floating point sample directly
      sval = const_mem(float, src);
#else
      // read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
      svp[0] = (cast(uint32_t, src[0]) << 24) + (cast(uint32_t, src[1]) << 16) + (cast(uint32_t, src[2]) << 8) + (cast(uint32_t, src[3]));
#endif
      // convert one type of floating point sample to another
      dval = cast(double, sval);
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // write floating point sample directly
      mem(double, dst) = dval;
#else
      // write sample bytes to destination
      dst[0] = cast(uint8_t, dvp[0] >> 56);
      dst[1] = cast(uint8_t, dvp[0] >> 48);
      dst[2] = cast(uint8_t, dvp[0] >> 40);
      dst[3] = cast(uint8_t, dvp[0] >> 32);
      dst[4] = cast(uint8_t, dvp[0] >> 24);
      dst[5] = cast(uint8_t, dvp[0] >> 16);
      dst[6] = cast(uint8_t, dvp[0] >> 8);
      dst[7] = cast(uint8_t, dvp[0]);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert Double (BE) samples to 16bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_DoubleBE_to_16bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const double factor = pow(2.0, 31.0);
  double   sval;
  sint32_t dval;
  uint64_t *svp = (uint64_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 8;
  dstflen -= nchannels * 2;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 8, dst += 2)
    {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // read floating point sample directly
      sval = const_mem(double, src);
#else
      // read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
      svp[0] = (cast(uint64_t, src[0]) << 56) + (cast(uint64_t, src[1]) << 48) + (cast(uint64_t, src[2]) << 40) + (cast(uint64_t, src[3]) << 32) + (cast(uint64_t, src[4]) << 24) + (cast(uint64_t, src[5]) << 16) + (cast(uint64_t, src[6]) << 8) + (cast(uint64_t, src[7]));
#endif
      // apply dither
      if (ditherer) ditherer->Dither(i, sval, 16);
      // convert floating point sample to integer sample (scale and limit)
      dval = cast(sint32_t, limited::limit(sval * factor, -2147483648.0, 2147483647.0));
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // write 16-bit integer sample directly
      mem(sint16_t, dst) = cast(sint16_t, dval >> 16);
#else
      // write sample bytes to destination
      dst[0] = cast(uint8_t, dvp[0] >> 24);
      dst[1] = cast(uint8_t, dvp[0] >> 16);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert Double (BE) samples to 24bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_DoubleBE_to_24bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const double factor = pow(2.0, 31.0);
  double   sval;
  sint32_t dval;
  uint64_t *svp = (uint64_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 8;
  dstflen -= nchannels * 3;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 8, dst += 3)
    {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // read floating point sample directly
      sval = const_mem(double, src);
#else
      // read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
      svp[0] = (cast(uint64_t, src[0]) << 56) + (cast(uint64_t, src[1]) << 48) + (cast(uint64_t, src[2]) << 40) + (cast(uint64_t, src[3]) << 32) + (cast(uint64_t, src[4]) << 24) + (cast(uint64_t, src[5]) << 16) + (cast(uint64_t, src[6]) << 8) + (cast(uint64_t, src[7]));
#endif
      // apply dither
      if (ditherer) ditherer->Dither(i, sval, 8);
      // convert floating point sample to integer sample (scale and limit)
      dval = cast(sint32_t, limited::limit(sval * factor, -2147483648.0, 2147483647.0));
      // write sample bytes to destination
      dst[0] = cast(uint8_t, dvp[0] >> 24);
      dst[1] = cast(uint8_t, dvp[0] >> 16);
      dst[2] = cast(uint8_t, dvp[0] >> 8);
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert Double (BE) samples to 32bit (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_DoubleBE_to_32bitBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  static const double factor = pow(2.0, 31.0);
  double   sval;
  sint32_t dval;
  uint64_t *svp = (uint64_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 8;
  dstflen -= nchannels * 4;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 8, dst += 4)
    {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // read floating point sample directly
      sval = const_mem(double, src);
#else
      // read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
      svp[0] = (cast(uint64_t, src[0]) << 56) + (cast(uint64_t, src[1]) << 48) + (cast(uint64_t, src[2]) << 40) + (cast(uint64_t, src[3]) << 32) + (cast(uint64_t, src[4]) << 24) + (cast(uint64_t, src[5]) << 16) + (cast(uint64_t, src[6]) << 8) + (cast(uint64_t, src[7]));
#endif
      // apply dither
      if (ditherer) ditherer->Dither(i, sval, 0);
      // convert floating point sample to integer sample (scale and limit)
      dval = cast(sint32_t, limited::limit(sval * factor, -2147483648.0, 2147483647.0));
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // write integer sample directly
      mem(sint32_t, dst) = dval;
#else
      // write sample bytes to destination
      dst[0] = cast(uint8_t, dvp[0] >> 24);
      dst[1] = cast(uint8_t, dvp[0] >> 16);
      dst[2] = cast(uint8_t, dvp[0] >> 8);
      dst[3] = cast(uint8_t, dvp[0]);
#endif
    }
  }
}

/*--------------------------------------------------------------------------------*/
/** Convert Double (BE) samples to Float (BE) samples
 */
/*--------------------------------------------------------------------------------*/
static void __Convert_DoubleBE_to_FloatBE(const uint8_t *src, uint8_t *dst, uint_t nchannels, uint_t nframes, sint_t srcflen, sint_t dstflen, Ditherer *ditherer)
{
  double   sval;
  float    dval;
  uint64_t *svp = (uint64_t *)&sval;
  uint32_t *dvp = (uint32_t *)&dval;
  uint_t i, j;

  (void)svp;
  (void)dvp;

  (void)ditherer;
  // adjust frame increments for effects of for-loop
  srcflen -= nchannels * 8;
  dstflen -= nchannels * 4;

  // process each frame
  for (i = 0; i < nframes; i++, src += srcflen, dst += dstflen)
  {
    // process each channel
    for (j = 0; j < nchannels; j++, src += 8, dst += 4)
    {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // read floating point sample directly
      sval = const_mem(double, src);
#else
      // read integer bytes representing floating point sample (note use of unsigned arithmetic to avoid problems with left shift)
      svp[0] = (cast(uint64_t, src[0]) << 56) + (cast(uint64_t, src[1]) << 48) + (cast(uint64_t, src[2]) << 40) + (cast(uint64_t, src[3]) << 32) + (cast(uint64_t, src[4]) << 24) + (cast(uint64_t, src[5]) << 16) + (cast(uint64_t, src[6]) << 8) + (cast(uint64_t, src[7]));
#endif
      // convert one type of floating point sample to another
      dval = cast(float, sval);
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      // write floating point sample directly
      mem(float, dst) = dval;
#else
      // write sample bytes to destination
      dst[0] = cast(uint8_t, dvp[0] >> 24);
      dst[1] = cast(uint8_t, dvp[0] >> 16);
      dst[2] = cast(uint8_t, dvp[0] >> 8);
      dst[3] = cast(uint8_t, dvp[0]);
#endif
    }
  }
}

const CONVERTSAMPLES SoundFormatConversions[2][2][SampleFormat_Count][SampleFormat_Count] =
{
  {
    {
      // LE -> LE
      {
        //  (LE) ->  (LE)
        NULL /* no valid conversion */,
        //  (LE) -> 16bit (LE)
        NULL /* no valid conversion */,
        //  (LE) -> 24bit (LE)
        NULL /* no valid conversion */,
        //  (LE) -> 32bit (LE)
        NULL /* no valid conversion */,
        //  (LE) -> Float (LE)
        NULL /* no valid conversion */,
        //  (LE) -> Double (LE)
        NULL /* no valid conversion */,
      },
      {
        // 16bit (LE) ->  (LE)
        NULL /* no valid conversion */,
        // 16bit (LE) -> 16bit (LE)
        &__CopyMemory_2,
        // 16bit (LE) -> 24bit (LE)
        &__Convert_16bitLE_to_24bitLE,
        // 16bit (LE) -> 32bit (LE)
        &__Convert_16bitLE_to_32bitLE,
        // 16bit (LE) -> Float (LE)
        &__Convert_16bitLE_to_FloatLE,
        // 16bit (LE) -> Double (LE)
        &__Convert_16bitLE_to_DoubleLE,
      },
      {
        // 24bit (LE) ->  (LE)
        NULL /* no valid conversion */,
        // 24bit (LE) -> 16bit (LE)
        &__Convert_24bitLE_to_16bitLE,
        // 24bit (LE) -> 24bit (LE)
        &__CopyMemory_3,
        // 24bit (LE) -> 32bit (LE)
        &__Convert_24bitLE_to_32bitLE,
        // 24bit (LE) -> Float (LE)
        &__Convert_24bitLE_to_FloatLE,
        // 24bit (LE) -> Double (LE)
        &__Convert_24bitLE_to_DoubleLE,
      },
      {
        // 32bit (LE) ->  (LE)
        NULL /* no valid conversion */,
        // 32bit (LE) -> 16bit (LE)
        &__Convert_32bitLE_to_16bitLE,
        // 32bit (LE) -> 24bit (LE)
        &__Convert_32bitLE_to_24bitLE,
        // 32bit (LE) -> 32bit (LE)
        &__CopyMemory_4,
        // 32bit (LE) -> Float (LE)
        &__Convert_32bitLE_to_FloatLE,
        // 32bit (LE) -> Double (LE)
        &__Convert_32bitLE_to_DoubleLE,
      },
      {
        // Float (LE) ->  (LE)
        NULL /* no valid conversion */,
        // Float (LE) -> 16bit (LE)
        &__Convert_FloatLE_to_16bitLE,
        // Float (LE) -> 24bit (LE)
        &__Convert_FloatLE_to_24bitLE,
        // Float (LE) -> 32bit (LE)
        &__Convert_FloatLE_to_32bitLE,
        // Float (LE) -> Float (LE)
        &__CopyMemory_4,
        // Float (LE) -> Double (LE)
        &__Convert_FloatLE_to_DoubleLE,
      },
      {
        // Double (LE) ->  (LE)
        NULL /* no valid conversion */,
        // Double (LE) -> 16bit (LE)
        &__Convert_DoubleLE_to_16bitLE,
        // Double (LE) -> 24bit (LE)
        &__Convert_DoubleLE_to_24bitLE,
        // Double (LE) -> 32bit (LE)
        &__Convert_DoubleLE_to_32bitLE,
        // Double (LE) -> Float (LE)
        &__Convert_DoubleLE_to_FloatLE,
        // Double (LE) -> Double (LE)
        &__CopyMemory_8,
      },
    },
    {
      // LE -> BE
      {
        //  (LE) ->  (BE)
        NULL /* no valid conversion */,
        //  (LE) -> 16bit (BE)
        NULL /* no valid conversion */,
        //  (LE) -> 24bit (BE)
        NULL /* no valid conversion */,
        //  (LE) -> 32bit (BE)
        NULL /* no valid conversion */,
        //  (LE) -> Float (BE)
        NULL /* no valid conversion */,
        //  (LE) -> Double (BE)
        NULL /* no valid conversion */,
      },
      {
        // 16bit (LE) ->  (BE)
        NULL /* no valid conversion */,
        // 16bit (LE) -> 16bit (BE)
        &__Convert_16bitLE_to_16bitBE,
        // 16bit (LE) -> 24bit (BE)
        &__Convert_16bitLE_to_24bitBE,
        // 16bit (LE) -> 32bit (BE)
        &__Convert_16bitLE_to_32bitBE,
        // 16bit (LE) -> Float (BE)
        &__Convert_16bitLE_to_FloatBE,
        // 16bit (LE) -> Double (BE)
        &__Convert_16bitLE_to_DoubleBE,
      },
      {
        // 24bit (LE) ->  (BE)
        NULL /* no valid conversion */,
        // 24bit (LE) -> 16bit (BE)
        &__Convert_24bitLE_to_16bitBE,
        // 24bit (LE) -> 24bit (BE)
        &__Convert_24bitLE_to_24bitBE,
        // 24bit (LE) -> 32bit (BE)
        &__Convert_24bitLE_to_32bitBE,
        // 24bit (LE) -> Float (BE)
        &__Convert_24bitLE_to_FloatBE,
        // 24bit (LE) -> Double (BE)
        &__Convert_24bitLE_to_DoubleBE,
      },
      {
        // 32bit (LE) ->  (BE)
        NULL /* no valid conversion */,
        // 32bit (LE) -> 16bit (BE)
        &__Convert_32bitLE_to_16bitBE,
        // 32bit (LE) -> 24bit (BE)
        &__Convert_32bitLE_to_24bitBE,
        // 32bit (LE) -> 32bit (BE)
        &__Convert_32bitLE_to_32bitBE,
        // 32bit (LE) -> Float (BE)
        &__Convert_32bitLE_to_FloatBE,
        // 32bit (LE) -> Double (BE)
        &__Convert_32bitLE_to_DoubleBE,
      },
      {
        // Float (LE) ->  (BE)
        NULL /* no valid conversion */,
        // Float (LE) -> 16bit (BE)
        &__Convert_FloatLE_to_16bitBE,
        // Float (LE) -> 24bit (BE)
        &__Convert_FloatLE_to_24bitBE,
        // Float (LE) -> 32bit (BE)
        &__Convert_FloatLE_to_32bitBE,
        // Float (LE) -> Float (BE)
        &__Convert_FloatLE_to_FloatBE,
        // Float (LE) -> Double (BE)
        &__Convert_FloatLE_to_DoubleBE,
      },
      {
        // Double (LE) ->  (BE)
        NULL /* no valid conversion */,
        // Double (LE) -> 16bit (BE)
        &__Convert_DoubleLE_to_16bitBE,
        // Double (LE) -> 24bit (BE)
        &__Convert_DoubleLE_to_24bitBE,
        // Double (LE) -> 32bit (BE)
        &__Convert_DoubleLE_to_32bitBE,
        // Double (LE) -> Float (BE)
        &__Convert_DoubleLE_to_FloatBE,
        // Double (LE) -> Double (BE)
        &__Convert_DoubleLE_to_DoubleBE,
      },
    },
  },
  {
    {
      // BE -> LE
      {
        //  (BE) ->  (LE)
        NULL /* no valid conversion */,
        //  (BE) -> 16bit (LE)
        NULL /* no valid conversion */,
        //  (BE) -> 24bit (LE)
        NULL /* no valid conversion */,
        //  (BE) -> 32bit (LE)
        NULL /* no valid conversion */,
        //  (BE) -> Float (LE)
        NULL /* no valid conversion */,
        //  (BE) -> Double (LE)
        NULL /* no valid conversion */,
      },
      {
        // 16bit (BE) ->  (LE)
        NULL /* no valid conversion */,
        // 16bit (BE) -> 16bit (LE)
        &__Convert_16bitBE_to_16bitLE,
        // 16bit (BE) -> 24bit (LE)
        &__Convert_16bitBE_to_24bitLE,
        // 16bit (BE) -> 32bit (LE)
        &__Convert_16bitBE_to_32bitLE,
        // 16bit (BE) -> Float (LE)
        &__Convert_16bitBE_to_FloatLE,
        // 16bit (BE) -> Double (LE)
        &__Convert_16bitBE_to_DoubleLE,
      },
      {
        // 24bit (BE) ->  (LE)
        NULL /* no valid conversion */,
        // 24bit (BE) -> 16bit (LE)
        &__Convert_24bitBE_to_16bitLE,
        // 24bit (BE) -> 24bit (LE)
        &__Convert_24bitBE_to_24bitLE,
        // 24bit (BE) -> 32bit (LE)
        &__Convert_24bitBE_to_32bitLE,
        // 24bit (BE) -> Float (LE)
        &__Convert_24bitBE_to_FloatLE,
        // 24bit (BE) -> Double (LE)
        &__Convert_24bitBE_to_DoubleLE,
      },
      {
        // 32bit (BE) ->  (LE)
        NULL /* no valid conversion */,
        // 32bit (BE) -> 16bit (LE)
        &__Convert_32bitBE_to_16bitLE,
        // 32bit (BE) -> 24bit (LE)
        &__Convert_32bitBE_to_24bitLE,
        // 32bit (BE) -> 32bit (LE)
        &__Convert_32bitBE_to_32bitLE,
        // 32bit (BE) -> Float (LE)
        &__Convert_32bitBE_to_FloatLE,
        // 32bit (BE) -> Double (LE)
        &__Convert_32bitBE_to_DoubleLE,
      },
      {
        // Float (BE) ->  (LE)
        NULL /* no valid conversion */,
        // Float (BE) -> 16bit (LE)
        &__Convert_FloatBE_to_16bitLE,
        // Float (BE) -> 24bit (LE)
        &__Convert_FloatBE_to_24bitLE,
        // Float (BE) -> 32bit (LE)
        &__Convert_FloatBE_to_32bitLE,
        // Float (BE) -> Float (LE)
        &__Convert_FloatBE_to_FloatLE,
        // Float (BE) -> Double (LE)
        &__Convert_FloatBE_to_DoubleLE,
      },
      {
        // Double (BE) ->  (LE)
        NULL /* no valid conversion */,
        // Double (BE) -> 16bit (LE)
        &__Convert_DoubleBE_to_16bitLE,
        // Double (BE) -> 24bit (LE)
        &__Convert_DoubleBE_to_24bitLE,
        // Double (BE) -> 32bit (LE)
        &__Convert_DoubleBE_to_32bitLE,
        // Double (BE) -> Float (LE)
        &__Convert_DoubleBE_to_FloatLE,
        // Double (BE) -> Double (LE)
        &__Convert_DoubleBE_to_DoubleLE,
      },
    },
    {
      // BE -> BE
      {
        //  (BE) ->  (BE)
        NULL /* no valid conversion */,
        //  (BE) -> 16bit (BE)
        NULL /* no valid conversion */,
        //  (BE) -> 24bit (BE)
        NULL /* no valid conversion */,
        //  (BE) -> 32bit (BE)
        NULL /* no valid conversion */,
        //  (BE) -> Float (BE)
        NULL /* no valid conversion */,
        //  (BE) -> Double (BE)
        NULL /* no valid conversion */,
      },
      {
        // 16bit (BE) ->  (BE)
        NULL /* no valid conversion */,
        // 16bit (BE) -> 16bit (BE)
        &__CopyMemory_2,
        // 16bit (BE) -> 24bit (BE)
        &__Convert_16bitBE_to_24bitBE,
        // 16bit (BE) -> 32bit (BE)
        &__Convert_16bitBE_to_32bitBE,
        // 16bit (BE) -> Float (BE)
        &__Convert_16bitBE_to_FloatBE,
        // 16bit (BE) -> Double (BE)
        &__Convert_16bitBE_to_DoubleBE,
      },
      {
        // 24bit (BE) ->  (BE)
        NULL /* no valid conversion */,
        // 24bit (BE) -> 16bit (BE)
        &__Convert_24bitBE_to_16bitBE,
        // 24bit (BE) -> 24bit (BE)
        &__CopyMemory_3,
        // 24bit (BE) -> 32bit (BE)
        &__Convert_24bitBE_to_32bitBE,
        // 24bit (BE) -> Float (BE)
        &__Convert_24bitBE_to_FloatBE,
        // 24bit (BE) -> Double (BE)
        &__Convert_24bitBE_to_DoubleBE,
      },
      {
        // 32bit (BE) ->  (BE)
        NULL /* no valid conversion */,
        // 32bit (BE) -> 16bit (BE)
        &__Convert_32bitBE_to_16bitBE,
        // 32bit (BE) -> 24bit (BE)
        &__Convert_32bitBE_to_24bitBE,
        // 32bit (BE) -> 32bit (BE)
        &__CopyMemory_4,
        // 32bit (BE) -> Float (BE)
        &__Convert_32bitBE_to_FloatBE,
        // 32bit (BE) -> Double (BE)
        &__Convert_32bitBE_to_DoubleBE,
      },
      {
        // Float (BE) ->  (BE)
        NULL /* no valid conversion */,
        // Float (BE) -> 16bit (BE)
        &__Convert_FloatBE_to_16bitBE,
        // Float (BE) -> 24bit (BE)
        &__Convert_FloatBE_to_24bitBE,
        // Float (BE) -> 32bit (BE)
        &__Convert_FloatBE_to_32bitBE,
        // Float (BE) -> Float (BE)
        &__CopyMemory_4,
        // Float (BE) -> Double (BE)
        &__Convert_FloatBE_to_DoubleBE,
      },
      {
        // Double (BE) ->  (BE)
        NULL /* no valid conversion */,
        // Double (BE) -> 16bit (BE)
        &__Convert_DoubleBE_to_16bitBE,
        // Double (BE) -> 24bit (BE)
        &__Convert_DoubleBE_to_24bitBE,
        // Double (BE) -> 32bit (BE)
        &__Convert_DoubleBE_to_32bitBE,
        // Double (BE) -> Float (BE)
        &__Convert_DoubleBE_to_FloatBE,
        // Double (BE) -> Double (BE)
        &__CopyMemory_8,
      },
    },
  },
};

BBC_AUDIOTOOLBOX_END
